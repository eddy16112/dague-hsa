extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <plasma.h>
#include <core_blas.h>
#include <math.h>

#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma/cores/dplasma_zcores.h"

#define INIT 0
#define MAXI 1
#define SRCH 2
#define LDV  3

%}

/* Globals
 */
A            [type = "dague_ddesc_t *"]
IPIV         [type = "dague_ddesc_t *"]
V            [type = "dague_ddesc_t *"]
P            [type = "int"]
Q            [type = "int"]
INFO         [type = "int*"]

descA        [type = "tiled_matrix_desc_t" hidden=on default="*((tiled_matrix_desc_t*)A)" ]

/**************************************************
 *                    IP_in (pseudo task)
 **************************************************/
/* IP_in(k) */

/* // Execution space */
/* k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1) */

/* // Parallel partitioning */
/* :IPIV(k,k%Q) */

/* // Parameters */
/* READ  IP <- IPIV(k,k%Q)                                [type = PIVOT] */
/*          -> IP GETRF_SND(k,0,0..P-1,0)                 [type = PIVOT] */

/* BODY */
/*         /\* Nothing to do *\/ */
/* END */

/**************************************************
 *                    V_in (pseudo task)
 **************************************************/
V_in(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = 0..((descA.mt<P)?(descA.mt-1):(P-1))

// Parallel partitioning
:V((k+m)%P,k%Q)

// Parameters
READ  V <- V((k+m)%P,k%Q)                                       [type = SWAP]
        -> V GETRF_MAX(k,k+m,0)                                 [type = SWAP]

BODY
        /* Nothing to do */
END


/**************************************************
 *                    GETRF_MAX
 * Apply the scale and the update of the step h-1
 * Look for the local max of the step h
 **************************************************/
GETRF_MAX(k,m,h)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

// Parallel partitioning
:A(m, k)

 //RW  T <- (k == 0) ? A(m, k) : C GEMM(k-1, m, k)
 //      -> T TRSM_U(k, k+1..descA.nt-1)
RW  T <- (h == 0)? A(m, k) : T GETRF_MAX(k,m,h-1)
      -> (h != hmax)? T GETRF_MAX(k,m,h+1)
      -> (h == hmax)? T GETRF_FNL(k,m)
RW  V <- ((h == 0) && (m-k<P))? V V_in(k,m-k)                     [type = SWAP]
      <- ((h != 0) && (m-k<P))? W GETRF_SND(k,dmax,(m-k)%P,h-1)   [type = SWAP]
      <- (m-k >= P)? V GETRF_MAX(k,m-P,h)                         [type = SWAP]
      -> ((descA.mt-m)>P)? V GETRF_MAX(k,m+P,h)                   [type = SWAP]
      -> ((descA.mt-m) <= P)? V GETRF_SND(k,0,((m-k)%P),h)        [type = SWAP]
      -> ((descA.mt-m) <= P)? W GETRF_SND(k,0,((m-k+1)%P),h)      [type = SWAP]

BODY
    DRYRUN(
       int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
       int minMN = (tempmm < tempkn)? tempmm : tempkn;
       int ldam = BLKLDD( descA, m );
       int i;
       int j;
       if(h != 0)		/* Applying the previous swap */
       {
	 Dague_Complex64_t alpha = ((Dague_Complex64_t) 1.) / (((Dague_Complex64_t *) V)[MAXI]);
	 int p = (m == k)? h : 0;
	 cblas_zscal(tempmm-p, CBLAS_SADDR( alpha ), (void *)(((uintptr_t)T)+(((h-1)*ldam+p)*sizeof(Dague_Complex64_t))), 1 );
	 Dague_Complex64_t mzone = -1.;
	 if ( k < minMN )
             cblas_zgeru(CblasColMajor, tempmm-p, tempkn-h,
                         CBLAS_SADDR(mzone),
                         (void *)(((uintptr_t)T)+(((h-1)*ldam+p)*sizeof(Dague_Complex64_t))), 1,
                         (void *)(((uintptr_t)V)+((LDV+MAXI)*sizeof(Dague_Complex64_t))),    LDV,
                         (void *)(((uintptr_t)T)+((h*ldam+p)*sizeof(Dague_Complex64_t))),    ldam);	 
       }
       if(m == k) 		/* Saving the default swap line */
       {
          for(i = 0; i < (tempkn-h); i++)
	    ((Dague_Complex64_t *) V)[LDV*i+INIT] = ((Dague_Complex64_t *) V)[LDV*i+SRCH]  = ((Dague_Complex64_t *) T)[ldam*(i+h)+h];
       }
       for(i = h; i < tempmm; i++) /* Looking for the local max */
	 if(cabs(((Dague_Complex64_t *) T)[ldam*h+i]) > cabs(((Dague_Complex64_t *) V)[SRCH]))
	   cblas_zcopy(tempkn-h,
		       (void *)(((uintptr_t)T)+(((ldam*h)+i)*sizeof(Dague_Complex64_t))), ldam,
		       (void *)(((uintptr_t)V)+(SRCH*sizeof(Dague_Complex64_t))), LDV);
/*             for(j = 0; j < tempkn-h; j++) */
/*               ((Dague_Complex64_t *) V)[LDV*j+SRCH] = ((Dague_Complex64_t *) T)[ldam*(j+h)+i]; */
          );
    printlog();
END


/**************************************************
 *                    GETRF_SND
 * Look and share the global max of the step h 
 * by using the Bruck algorithm
 **************************************************/
GETRF_SND(k,d,m,h)

k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
d = 0.. inline_c %{ 
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i;%}
m = 0..((descA.mt-k < P) ? (descA.mt-k-1) : (P-1))
h = 0..inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

mmax = inline_c %{return ((descA.mt-k < P) ? descA.mt-k : P); %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}

pui= inline_c %{ return (int) pow(2,d+1); %}

// Parallel partitioning
:A(k+m, k)

READ  V <- (d == 0)? V GETRF_MAX(k,descA.mt-((descA.mt-(k+m+1))%P)-1,h) : W GETRF_SND(k,d-1,m,h)           [type = SWAP]
RW    W <- (d == 0)? V GETRF_MAX(k,descA.mt-((descA.mt-(k+m))%P)-1,h) : W GETRF_SND(k,d-1,(P+m-pui/2)%P,h) [type = SWAP]
	-> (d != dmax)? V GETRF_SND(k,d+1,m,h)	                                                           [type = SWAP]
        -> (d != dmax)? W GETRF_SND(k,d+1,(m+pui)%P,h)	                                                   [type = SWAP]
	-> (d == dmax)? V GETRF_MAX(k,k+m,h+1)	                                                           [type = SWAP]
        -> ((h == hmax) && (d == dmax))? V GETRF_FNL(k,(k+m)..(descA.mt-((descA.mt-(k+m+1))%P)-1)..P)      [type = SWAP]
/* RW   IP <- ((d == 0) && (h == 0))? IP IP_in(k)                                                       [type = PIVOT] */
/*         <- ((d == 0) && (h != 0))? IP GETRF_SND(k,dmax,m,h-1)                                        [type = PIVOT] */
/* 	<- (d != 0)? IP GETRF_SND(k,d-1,m,h)                                                         [type = PIVOT] */
/* 	-> (d != dmax)? IP GETRF_SND(k,d+1,m,h)                                                      [type = PIVOT] */
/* 	-> ((d == dmax) && (h == descA.nb))? IP GETRF_SND(k,0,m,h+1)	                             [type = PIVOT] */

BODY
    DRYRUN(
       int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
/*        int j; */
       if(m  < pui && m < pui/2)
	 cblas_zcopy(tempkn-h,
		     (void *)(((uintptr_t)V)+(INIT*sizeof(Dague_Complex64_t))), LDV,
		     (void *)(((uintptr_t)W)+(INIT*sizeof(Dague_Complex64_t))), LDV);
/*          for(j = 0; j < tempkn-h; j++) */
/*            ((Dague_Complex64_t *) W)[LDV*j+INIT] = ((Dague_Complex64_t *) V)[LDV*j+INIT]; */

       if( cabs(((Dague_Complex64_t *) V)[SRCH]) > cabs(((Dague_Complex64_t *) W)[SRCH]) )
	 cblas_zcopy(tempkn-h,
		     (void *)(((uintptr_t)V)+(SRCH*sizeof(Dague_Complex64_t))), LDV,
		     (void *)(((uintptr_t)W)+(SRCH*sizeof(Dague_Complex64_t))), LDV);
/*          for(j = 0; j < tempkn-h; j++) */
/*            ((Dague_Complex64_t *) W)[LDV*j+SRCH] = ((Dague_Complex64_t *) V)[LDV*j+SRCH]; */

       if(d == dmax)
	 cblas_zcopy(tempkn-h,
		     (void *)(((uintptr_t)W)+(SRCH*sizeof(Dague_Complex64_t))), LDV,
		     (void *)(((uintptr_t)W)+(MAXI*sizeof(Dague_Complex64_t))), LDV);
/*          for(j = 0; j < tempkn-h; j++) */
/*            ((Dague_Complex64_t *) W)[LDV*j+MAXI] = ((Dague_Complex64_t *) W)[LDV*j+SRCH]; */

          );
    printlog();
END

/**************************************************
 *                    GETRF_FNL
 * Apply the last scale and update. Then send the
 * pivot to the swap operations.
 **************************************************/
GETRF_FNL(k,m)

// Execution space
k = 0..((descA.mt<descA.nt)?descA.mt-1:descA.nt-1)
m = k..descA.mt-1

dmax = inline_c %{
  int nb_init = (descA.mt-k < P) ? descA.mt-k : P;
  int i;
  for(i = 0; nb_init != 1 ; i++)
      nb_init/=2;
  return i; %}

hmax = inline_c %{ 
  int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
  int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
  return ((tempkm<tempkn)? tempkm : tempkn)-1; %}


// Parallel partitioning
:A(m, k)

RW  T <- T GETRF_MAX(k,m,hmax)
      -> A(m, k)
READ  V <- W GETRF_SND(k,dmax,(m-k)%P,hmax)       [type = SWAP]

BODY
 DRYRUN(
/*      Dague_Complex64_t alpha = ((Dague_Complex64_t) 1.) / (((Dague_Complex64_t *) V)[MAXI]); */
/*      int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb); */
/*      int ldam = BLKLDD( descA, m ); */
/*      cblas_zscal(tempmm-hmax, CBLAS_SADDR( alpha ), (void *)(((uintptr_t)T)+((hmax*ldam+hmax-1)*sizeof(Dague_Complex64_t))), 1 ); */
       );
    printlog();
END
