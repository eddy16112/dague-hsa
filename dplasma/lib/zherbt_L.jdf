extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */

#define DAGUE_CALL_TRACE 1

#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_dist/matrix/matrix.h"
#include "dplasmajdf.h"

#include "data_distribution.h"
#include "memory_pool.h"

/* For now dplasma doesn't store matrices as PLASMA => no need for lm1 and BLKLDD */
/* #define BLKLDD(k) ( ( (k) + desc_A.i/desc_A.mb) < desc_A.lm1 ? desc_A.mb : desc_A.lm%desc_A.mb )*/
#define BLKLDD(k) desc_A.mb
%}

uplo [type = "PLASMA_enum"]
desc_A [type = "PLASMA_desc"]
data_A [type = "dague_ddesc_t*"]
desc_T [type = "PLASMA_desc"]
data_T [type = "dague_ddesc_t*" aligned=data_A]
IB     [type = int]
pool_0 [type = "dague_memory_pool_t *"]
pool_1 [type = "dague_memory_pool_t *"]
pool_2 [type = "dague_memory_pool_t *"]
pool_3 [type = "dague_memory_pool_t *"]

zgeqrt(k)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1

  : data_A(k+1,k)

  /* A == data_A(k+1,k) */
  /* B == data_T(k+1,k) */
  /* C == data_A(k+1,k) */
  /* D == data_T(k+1,k) */
  /* F == data_A(k+1,k) */
  /* G == data_T(k+1,k) */
  /* J == data_A(k+1,k) */
  /* M == data_A(i,k+1) */
  /* V == data_A(m1,k+1) */

  RW    A <- ((k+2)==desc_A.mt) & (desc_A.nt>=(2+k)) & (k>=1) ? V ztsmqrlr(desc_A.mt-1-2, k+1) 
          <- (desc_A.mt>=(3+k)) & (k>=1) ? M ztsmqr1(k+1-2, desc_A.mt-1, k+1) 
          <- ( ((0==k)) | ((k>=1) & ((1+k)>=desc_A.mt)) ) ? data_A(k+1,k)
          -> C zherfb1(k) 
          -> (desc_A.mt>=(k+3)) ? J ztsqrt(k, k+2) 
          -> ((k+2)>=desc_A.mt) ? data_A(k+1,k)
          -> (desc_A.mt>=(k+3)) ? F zunmqr(k, (k+2)..(desc_A.mt-1)) 
  RW    B <- data_T(k+1,k)                                                 [type = LITTLE_T]
          -> D zherfb1(k)                                                  [type = LITTLE_T]
          -> (desc_A.mt>=(3+k)) ? G zunmqr(k, (k+2)..(desc_A.mt-1))        [type = LITTLE_T]
          -> data_T(k+1,k)                                                 [type = LITTLE_T]

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkn = ((k+1)==((desc_A.nt)-1)) ? ((desc_A.n)-((k+1)*(desc_A.nb))) : (desc_A.nb);
  int ib = IB;
  int ldak = BLKLDD( k+1 );

  void *pool_A = dague_private_memory_pop( pool_0 );
  void *pool_B = dague_private_memory_pop( pool_1 );

#line 66 "pzherbt-L.c"
#if 0
  CORE_zgeqrt(tempkn, desc_A.nb, ib, 
	A /* data_A(k+1,k) */, ldak, B /* data_T(k+1,k) */, 
	desc_T.mb, pool_A, pool_B );
#endif
  dague_private_memory_push( pool_0, pool_A );
  dague_private_memory_push( pool_1, pool_B );

  printlog("thread %d CORE_zgeqrt(%d)\n\t(tempkn, desc_A.nb, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T.mb, pool_A, pool_B)\n",
  context->eu_id, k, k+1, k, A, k+1, k, B);

END


zherfb1(k)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1

  : data_A(k+1,k+1)

  /* A == data_A(k+1,k) */
  /* B == data_T(k+1,k) */
  /* C == data_A(k+1,k) */
  /* D == data_T(k+1,k) */
  /* E == data_A(k+1,k+1) */
  /* U == data_A(k+1,k+1) */
  /* W == data_A(m1,m1) */

  READ  C <- A zgeqrt(k) 
  READ  D <- B zgeqrt(k) 
  RW    E <- ( ((0==k)) | ((k>=1) & ((k+1)>=desc_A.mt)) ) ? data_A(k+1,k+1)
          <- (desc_A.mt>=(k+2)) & (k>=1) ? W ztsmqrlr(k+1-2, k+1) 
          -> ((2+k)>=desc_A.mt) ? data_A(k+1,k+1)
          -> (desc_A.mt>=(3+k)) ? U ztsmqrlr(k, k+2) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempkn = ((k+1)==((desc_A.nt)-1)) ? ((desc_A.n)-((k+1)*(desc_A.nb))) : (desc_A.nb);
  int ib = IB;
  int ldak = BLKLDD( k+1 );

  void *pool_A = dague_private_memory_pop( pool_2 );

#line 78 "pzherbt-L.c"
#if 0
  CORE_zherfb1(PlasmaLower, tempkn, tempkn, 
	ib, desc_T.nb, C /* data_A(k+1,k) */, 
	ldak, D /* data_T(k+1,k) */, desc_T.mb, 
	E /* data_A(k+1,k+1) */, ldak, pool_A, 
	desc_T.nb );
#endif
  dague_private_memory_push( pool_2, pool_A );

  printlog("thread %d CORE_zherfb1(%d)\n\t(PlasmaLower, tempkn, tempkn, ib, desc_T.nb, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T.mb, A(%d,%d)[%p], ldak, pool_A, desc_T.nb)\n",
  context->eu_id, k, k+1, k, C, k+1, k, D, k+1, k+1, E);

END


zunmqr(k,m)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m = k+2..desc_A.mt-1

  : data_A(m,k+1)

  /* A == data_A(k+1,k) */
  /* B == data_T(k+1,k) */
  /* F == data_A(k+1,k) */
  /* G == data_T(k+1,k) */
  /* H == data_A(m,k+1) */
  /* N == data_A(m1,i) */
  /* Q == data_A(j,k+1) */
  /* V == data_A(m1,k+1) */

  READ  F <- A zgeqrt(k) 
  READ  G <- B zgeqrt(k)                                       [ type = LITTLE_T ]
  RW    H <- (0==k) ? data_A(m,k+1)
          <- (k>=1) ? N ztsmqr1(k+1-2, m, k+1) 
          -> (m==(k+2)) & (desc_A.nt>=m) ? V ztsmqrlr(m-2, m) 
          -> (m>=(3+k)) ? Q ztsmqr(k, k+2, m) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m)==((desc_A.mt)-1)) ? ((desc_A.m)-(m*(desc_A.mb))) : (desc_A.mb);
  int tempkn = ((k+1)==((desc_A.nt)-1)) ? ((desc_A.n)-((k+1)*(desc_A.nb))) : (desc_A.nb);
  int ib = IB;
  int ldak = BLKLDD( k+1 );
  int ldam = BLKLDD( m );

  void *pool_A = dague_private_memory_pop( pool_1 );

#line 97 "pzherbt-L.c"
#if 0
  CORE_zunmqr(PlasmaRight, PlasmaNoTrans, tempmm, 
	desc_A.nb, tempkn, ib, 
	F /* data_A(k+1,k) */, ldak, G /* data_T(k+1,k) */, 
	desc_T.mb, H /* data_A(m,k+1) */, ldam, 
	pool_A, desc_T.nb );
#endif
  dague_private_memory_push( pool_1, pool_A );

  printlog("thread %d CORE_zunmqr(%d, %d)\n\t(PlasmaRight, PlasmaNoTrans, tempmm, desc_A.nb, tempkn, ib, A(%d,%d)[%p], ldak, T(%d,%d)[%p], desc_T.mb, A(%d,%d)[%p], ldam, pool_A, desc_T.nb)\n",
  context->eu_id, k, m, k+1, k, F, k+1, k, G, m, k+1, H);

END

ztsqrt_out_data_A(k)
  k = 0..(((desc_A.mt-3)<(desc_A.nt-2))?(desc_A.mt-3):(desc_A.nt-1-1))

  : data_A(k+1,k)

  RW A <- J ztsqrt(k, desc_A.mt-1)
       -> data_A(k+1, k)

BODY
 /* NOTHING */
END

ztsqrt(k,m1)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1

  : data_A(m1,k)

  /* A == data_A(k+1,k) */
  /* J == data_A(k+1,k) */
  /* K == data_A(m1,k) */
  /* L == data_T(m1,k) */
  /* M == data_A(i,k+1) */
  /* O == data_A(m1,k) */
  /* P == data_T(m1,k) */
  /* S == data_A(m1,k) */
  /* T == data_T(m1,k) */
  /* V == data_A(m1,k+1) */
  /* X == data_A(m1,k) */
  /* Y == data_T(m1,k) */

  RW    J <- (m1>=(3+k)) ? J ztsqrt(k, m1-1) 
          <- ((k+2)==m1) & (desc_A.nt>=(k+2)) ? A zgeqrt(m1-2) 
          -> (desc_A.mt==(m1+1)) ? A ztsqrt_out_data_A(k)
          -> (desc_A.mt>=(m1+2)) ? J ztsqrt(k, m1+1) 
  RW    K <- ((m1+1)==desc_A.mt) & (k>=1) ? V ztsmqrlr(k-1, desc_A.mt-1) 
          <- (0==k) ? data_A(m1,k)
          <- (desc_A.mt>=(m1+2)) & (k>=1) ? M ztsmqr1(k-1, desc_A.mt-1, m1) 
          -> (desc_A.mt>=(m1+2)) ? S ztsmqr(k, m1, (m1+1)..(desc_A.mt-1)) 
          -> X ztsmqrlr(k, m1) 
          -> data_A(m1,k)
          -> (m1>=(k+3)) ? O ztsmqr1(k, m1, (k+2)..(m1-1)) 
  RW    L <- data_T(m1,k)                                                     [ type = LITTLE_T ]
          -> (m1>=(k+3)) ? P ztsmqr1(k, m1, (k+2)..(m1-1))                    [ type = LITTLE_T ]
          -> data_T(m1,k)                                                     [ type = LITTLE_T ]
          -> (desc_A.mt>=(m1+2)) ? T ztsmqr(k, m1, (m1+1)..(desc_A.mt-1))     [ type = LITTLE_T ]
          -> Y ztsmqrlr(k, m1)                                                [ type = LITTLE_T ]

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m1)==((desc_A.mt)-1)) ? ((desc_A.m)-(m1*(desc_A.mb))) : (desc_A.mb);
  int ib = IB;
  int ldak = BLKLDD( k+1 );
  int ldam = BLKLDD( m1 );

  void *pool_A = dague_private_memory_pop( pool_0 );
  void *pool_B = dague_private_memory_pop( pool_1 );

#line 118 "pzherbt-L.c"
#if 0
  CORE_ztsqrt(tempmm, desc_A.nb, ib, 
	J /* data_A(k+1,k) */, ldak, K /* data_A(m1,k) */, 
	ldam, L /* data_T(m1,k) */, desc_T.mb, 
	pool_A, pool_B );
#endif
  dague_private_memory_push( pool_0, pool_A );
  dague_private_memory_push( pool_1, pool_B );

  printlog("thread %d CORE_ztsqrt(%d, %d)\n\t(tempmm, desc_A.nb, ib, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T.mb, pool_A, pool_B)\n",
  context->eu_id, k, m1, k+1, k, J, m1, k, K, m1, k, L);

END

ztsmqr1_out_data_A(k,m1,i)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1
  i = k+2..m1-1
  
  : data_A(i,k+1)

RW A <- (desc_A.mt==(m1+1)) & ((2+k)==desc_A.nt) & (i>=(k+2)) & (desc_A.mt>=(k+3)) ? M ztsmqr1(k,m1,i)
     -> (desc_A.mt==(m1+1)) & ((2+k)==desc_A.nt) & (i>=(k+2)) & (desc_A.mt>=(k+3)) ? data_A(i,k+1)

BODY
  /* Nothing */
END

ztsmqr1(k,m1,i)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1
  i = k+2..m1-1

  : data_A(m1,i)

  /* A == data_A(k+1,k) */
  /* H == data_A(m,k+1) */
  /* K == data_A(m1,k) */
  /* L == data_T(m1,k) */
  /* M == data_A(i,k+1) */
  /* N == data_A(m1,i) */
  /* O == data_A(m1,k) */
  /* P == data_T(m1,k) */
  /* R == data_A(j,m1) */
  /* V == data_A(m1,k+1) */

  RW    M <- ((i+1)==m1) ? V ztsmqrlr(k, m1-1) 
          <- (m1>=(i+2)) ? M ztsmqr1(k, m1-1, i) 
          -> (desc_A.mt==(m1+1)) & ((k+2)==i) & (desc_A.nt>=(k+3)) ? A zgeqrt(i-1) 
          -> (desc_A.mt>=(m1+2)) ? M ztsmqr1(k, m1+1, i) 
          -> (desc_A.mt==(m1+1)) & ((2+k)==desc_A.nt) & (i>=(k+2)) & (desc_A.mt>=(k+3)) ? A ztsmqr1_out_data_A(k,m1,i)
          -> (desc_A.mt==(1+m1)) & (i>=(3+k)) & (desc_A.nt>=(k+3)) ? K ztsqrt(k+1, i) 
  RW    N <- (k>=1) ? N ztsmqr1(k-1, m1, i) 
          <- R ztsmqr(k, i, m1) 
          -> (i>=(k+3)) & (desc_A.nt>=(k+3)) ? N ztsmqr1(k+1, m1, i) 
          -> (desc_A.nt==(k+2)) ? data_A(m1,i)
          -> ((2+k)==i) & (desc_A.nt>=(k+3)) ? H zunmqr(i-1, m1) 
  READ  O <- K ztsqrt(k, m1) 
  READ  P <- L ztsqrt(k, m1)                                               [ type = LITTLE_T ]

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m1)==((desc_A.mt)-1)) ? ((desc_A.m)-(m1*(desc_A.mb))) : (desc_A.mb);
  int ib = IB;
  int ldai = BLKLDD( i );
  int ldam = BLKLDD( m1 );
  int ldwork = ((PlasmaLeft)==(PlasmaLeft)) ? (ib) : (desc_T.nb);

  void *pool_A = dague_private_memory_pop( pool_1 );

#line 135 "pzherbt-L.c"
#if 0
  CORE_ztsmqr1(PlasmaLeft, PlasmaConjTrans, desc_A.mb, 
	desc_A.nb, tempmm, desc_A.nb, 
	desc_A.nb, ib, M /* data_A(i,k+1) */, 
	ldai, N /* data_A(m1,i) */, ldam, 
	O /* data_A(m1,k) */, ldam, P /* data_T(m1,k) */, 
	desc_T.mb, pool_A, ldwork );
#endif
  dague_private_memory_push( pool_1, pool_A );

  printlog("thread %d CORE_ztsmqr1(%d, %d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, desc_A.mb, desc_A.nb, tempmm, desc_A.nb, desc_A.nb, ib, A(%d,%d)[%p], ldai, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T.mb, pool_A, ldwork)\n",
  context->eu_id, k, m1, i, i, k+1, M, m1, i, N, m1, k, O, m1, k, P);

END


ztsmqr(k,m1,j)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1
  j = m1+1..desc_A.mt-1

  : data_A(j,m1) /* Placement might be suboptimal */

  /* H == data_A(m,k+1) */
  /* K == data_A(m1,k) */
  /* L == data_T(m1,k) */
  /* N == data_A(m1,i) */
  /* Q == data_A(j,k+1) */
  /* R == data_A(j,m1) */
  /* S == data_A(m1,k) */
  /* T == data_T(m1,k) */
  /* V == data_A(m1,k+1) */

  RW    Q <- ((k+2)==m1) & (desc_A.nt>=(k+2)) ? H zunmqr(m1-2, j) 
          <- (m1>=(k+3)) ? Q ztsmqr(k, m1-1, j) 
          -> (j>=(2+m1)) ? Q ztsmqr(k, m1+1, j) 
          -> ((1+m1)==j) ? V ztsmqrlr(k, j) 
  RW    R <- (k>=1) ? R ztsmqr(k-1, m1, j) 
          <- (0==k) ? data_A(j,m1)
          -> N ztsmqr1(k, j, m1) 
          -> (m1>=(k+3)) & (desc_A.nt>=(k+3)) ? R ztsmqr(k+1, m1, j) 
  READ  S <- K ztsqrt(k, m1) 
  READ  T <- L ztsqrt(k, m1)                                           [ type = LITTLE_T ]

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempjj = ((j)==((desc_A.mt)-1)) ? ((desc_A.m)-(j*(desc_A.mb))) : (desc_A.mb);
  int tempmm = ((m1)==((desc_A.mt)-1)) ? ((desc_A.m)-(m1*(desc_A.mb))) : (desc_A.mb);
  int ib = IB;
  int ldaj = BLKLDD( j );
  int ldam = BLKLDD( m1 );
  int ldwork = ((PlasmaRight)==(PlasmaLeft)) ? (ib) : (desc_T.nb);

  void *pool_A = dague_private_memory_pop( pool_1 );

#line 161 "pzherbt-L.c"
#if 0
  CORE_ztsmqr(PlasmaRight, PlasmaNoTrans, tempjj, 
	desc_A.nb, tempjj, tempmm, 
	desc_A.nb, ib, Q /* data_A(j,k+1) */, 
	ldaj, R /* data_A(j,m1) */, ldaj, 
	S /* data_A(m1,k) */, ldam, T /* data_T(m1,k) */, 
	desc_T.mb, pool_A, ldwork );
#endif
  dague_private_memory_push( pool_1, pool_A );

  printlog("thread %d CORE_ztsmqr(%d, %d, %d)\n\t(PlasmaRight, PlasmaNoTrans, tempjj, desc_A.nb, tempjj, tempmm, desc_A.nb, ib, A(%d,%d)[%p], ldaj, A(%d,%d)[%p], ldaj, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T.mb, pool_A, ldwork)\n",
  context->eu_id, k, m1, j, j, k+1, Q, j, m1, R, m1, k, S, m1, k, T);

END

ztsmqrlr_out_data_A(k,m1)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1

  : data_A(m1,k+1)

  RW A <- ( ((desc_A.nt==(k+2)) & (desc_A.mt==(1+m1)) & (desc_A.mt>=(2+desc_A.nt))) | ((desc_A.nt==m1) & (desc_A.nt==(k+2)) & ((desc_A.nt+1)==desc_A.mt)) ) ? V ztsmqrlr(k,m1)
       -> ( ((desc_A.nt==(k+2)) & (desc_A.mt==(1+m1)) & (desc_A.mt>=(2+desc_A.nt))) | ((desc_A.nt==m1) & (desc_A.nt==(k+2)) & ((desc_A.nt+1)==desc_A.mt)) ) ? data_A(m1,k+1)

BODY
 /* Nothing */
END
ztrsmqrlr_in_data_A(m1)
  m1 = 2..desc_A.mt-1

  : data_A(m1,m1)

 RW A <- data_A(m1,m1)
      -> W ztsmqrlr(0,m1)

BODY
 /* nothing */
END

ztsmqrlr_out2_data_A(m1)
  m1 = desc_A.nt..desc_A.mt-1

  : data_A(m1,m1)

  RW A <- W ztsmqrlr(desc_A.nt-2, m1)
       -> data_A(m1,m1)

BODY
 /* nothing */
END

ztsmqrlr(k,m1)
  /* Execution space */
  k = 0..(desc_A.nt)-1-1
  m1 = k+2..desc_A.mt-1

  : data_A(k+1,k+1)

  /* A == data_A(k+1,k) */
  /* E == data_A(k+1,k+1) */
  /* H == data_A(m,k+1) */
  /* K == data_A(m1,k) */
  /* L == data_T(m1,k) */
  /* M == data_A(i,k+1) */
  /* Q == data_A(j,k+1) */
  /* U == data_A(k+1,k+1) */
  /* V == data_A(m1,k+1) */
  /* W == data_A(m1,m1) */
  /* X == data_A(m1,k) */
  /* Y == data_T(m1,k) */

  RW    U <- ((k+2)==m1) & (desc_A.nt>=(k+2)) ? E zherfb1(m1-2) 
          <- (m1>=(3+k)) ? U ztsmqrlr(k, m1-1) 
          -> (desc_A.mt==(m1+1)) ? data_A(k+1,k+1)
          -> (desc_A.mt>=(m1+2)) ? U ztsmqrlr(k, m1+1) 
  RW    V <- ((k+2)==m1) & (desc_A.nt>=(k+2)) ? H zunmqr(m1-2, m1) 
          <- (m1>=(k+3)) ? Q ztsmqr(k, m1-1, m1) 
          -> (desc_A.mt==(m1+1)) & (desc_A.mt>=(k+4)) & (desc_A.nt>=(k+3)) ? K ztsqrt(k+1, m1) 
          -> (desc_A.mt>=(2+m1)) ? M ztsmqr1(k, m1+1, m1) 
          -> (desc_A.mt==(1+m1)) & (desc_A.mt==(k+3)) & (desc_A.nt>=desc_A.mt) ? A zgeqrt(m1-1) 
          -> ( ((desc_A.nt==(k+2)) & (desc_A.mt==(1+m1)) & (desc_A.mt>=(2+desc_A.nt))) | ((desc_A.nt==m1) & (desc_A.nt==(k+2)) & ((desc_A.nt+1)==desc_A.mt)) ) ? A ztsmqrlr_out_data_A(k,m1)
  RW    W <- (k>=1) ? W ztsmqrlr(k-1, m1) 
          <- (0==k) ? A ztrsmqrlr_in_data_A(m1)
          -> ((k+2)==m1) & (desc_A.nt>=(k+3)) ? E zherfb1(m1-1) 
          -> (m1>=(k+3)) & (desc_A.nt>=(k+3)) ? W ztsmqrlr(k+1, m1) 
          -> (desc_A.nt==(k+2)) ? A ztsmqrlr_out2_data_A(m1)
  READ  X <- K ztsqrt(k, m1) 
  READ  Y <- L ztsqrt(k, m1)                                 [ type = LITTLE_T ]

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  int tempmm = ((m1)==((desc_A.mt)-1)) ? ((desc_A.m)-(m1*(desc_A.mb))) : (desc_A.mb);
  int ib = IB;
  int ldak = BLKLDD( k+1 );
  int ldam = BLKLDD( m1 );
  int ldwork = desc_T.nb;

  void *pool_A = dague_private_memory_pop( pool_3 );

#line 183 "pzherbt-L.c"
#if 0
  CORE_ztsmqrlr(desc_A.nb, desc_A.nb, tempmm, 
	desc_A.nb, tempmm, tempmm, 
	desc_A.nb, ib, desc_T.nb, 
	U /* data_A(k+1,k+1) */, ldak, V /* data_A(m1,k+1) */, 
	ldam, W /* data_A(m1,m1) */, ldam, 
	X /* data_A(m1,k) */, ldam, Y /* data_T(m1,k) */, 
	desc_T.mb, pool_A, ldwork );
#endif
  dague_private_memory_push( pool_3, pool_A );

  printlog("thread %d CORE_ztsmqrlr(%d, %d)\n\t(desc_A.nb, desc_A.nb, tempmm, desc_A.nb, tempmm, tempmm, desc_A.nb, ib, desc_T.nb, A(%d,%d)[%p], ldak, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], desc_T.mb, pool_A, ldwork)\n",
  context->eu_id, k, m1, k+1, k+1, U, m1, k+1, V, m1, m1, W, m1, k, X, m1, k, Y);

END
