extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/matrix.h"

#define PRECISION_z
#define BLKLDD(_desc, _k) (_desc).mb
#define PIV(_i, _k) piv[(_k)*descA.mt+(_i)]

/* Return the pivot to use for the row m at step k */
 inline static int currpiv( const tiled_matrix_desc_t *desc, const int *ipiv, const int m, const int k ) {
   return ipiv[ k * desc->mt + m ];
 }

/* Return the last row which has used the row m as a pivot in step k before the row start */
 inline static int prevpiv( const tiled_matrix_desc_t *desc, const int *ipiv, const int p, const int k, const int start ) {
   int i;
   ipiv += k * desc->mt;
   for( i=start+1; i<desc->mt; i++ )
     if ( ipiv[i] == p )
       return i;
   return i;
 }

/* Return the next row which will use the row m as a pivot in step k after it has been used by row start */
 inline static int nextpiv( const tiled_matrix_desc_t *desc, const int *ipiv, const int p, const int k, const int start ) {
   int i;
   ipiv += k * desc->mt;
   for( i=start; i>k; i++ )
     if ( ipiv[i] == p )
       return i;
   return desc->mt;
 }

#define MYMIN(a, b) ((a)<(b)?(a):(b))

%}

descA  [type = "tiled_matrix_desc_t"]
A      [type = "dague_ddesc_t *"]
descT  [type = "tiled_matrix_desc_t"]
T      [type = "dague_ddesc_t *" aligned=A]
descT2 [type = "tiled_matrix_desc_t"]
T2     [type = "dague_ddesc_t *" aligned=A]
piv    [type = "int*"]
ib     [type = "int"]
p_work [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)*ib*(descT.nb))"]
p_tau  [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)   *(descT.nb))"]


zgeqrt(k, m)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k..descA.mt-1
  nextm = inline_c %{ return nextpiv(&descA, piv, m, k,   descA.mt); %}
  prevm = inline_c %{ return prevpiv(&descA, piv, k, k-1, k-1     ); %}

  : A(m, k)

  /* A == A(m, k) */
  /* T == T(m, k) */

  RW    A <- ( 0 == k ) ? A(m, k) 
          <- ( (k > 0) & (m == k) ) ? A1 zttmqr(k-1, prevm, k ) 
          <- ( (k > 0) & (m != k) ) ? A2 zttmqr(k-1, m, k ) 
          -> (descA.nt-1 > k) ? A zunmqr(k, m, (k+1)..(descA.nt-1)) 
          -> ( k == descA.mt-1 ) ? A(m, k)   
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ?  A1 zttqrt(k, nextm)
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ?  A2 zttqrt(k, m)
  RW    T <- T(m, k)                                                [type = LITTLE_T]
          -> T(m, k)                                                [type = LITTLE_T]
          -> (descA.nt-1 > k) ? T zunmqr(k, m, (k+1)..(descA.nt-1)) [type = LITTLE_T]
       
BODY
  void *p_elem_A = dague_private_memory_pop( p_tau  );
  void *p_elem_B = dague_private_memory_pop( p_work );

  DRYRUN(
  int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
  int tempkn = ((k)==((descA.nt)-1)) ? ((descA.n)-(k*(descA.nb))) : (descA.nb);
  int ldam = BLKLDD( descA, m );

  CORE_zgeqrt(tempmm, tempkn, ib, 
              A /* A(m,k) */, ldam, 
              T /* T(m,k) */, descT.mb, 
              p_elem_A, p_elem_B );
         );
  dague_private_memory_push( p_work, p_elem_A );
  dague_private_memory_push( p_work, p_elem_B );

  printlog("thread %d CORE_zgeqrt(%d, %d)\n\t(tempmm, tempkn, ib, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, p_elem_B)\n",
           context->eu_id, k, m, m, k, A, m, k, T);

END


zunmqr(k, m, n)
  /* Execution space */
  k = 0..( ( descA.mt < descA.nt ) ? descA.mt-1 : descA.nt-1)
  m = k..descA.mt-1
  n = k+1..descA.nt-1
  nextm = inline_c %{ return nextpiv(&descA, piv, m, k, descA.mt); %}

  : A(m, n)

  /* A == A(m,k) */
  /* T == T(m,k) */
  /* C == A(m,n) */

  READ  A <- A zgeqrt(k, m) 
  READ  T <- T zgeqrt(k, m)                                         [type = LITTLE_T]
  RW    C <- ( 0 == k ) ? A(m, n)
          <- ( ( k > 0 ) & (m == k) ) ? A1 zttmqr(k-1, inline_c %{ return prevpiv(&descA, piv, m, k-1, m); %}, n) 
          <- ( ( k > 0 ) & (m != k) ) ? A2 zttmqr(k-1, m, n) 
          -> ( k == descA.mt-1 ) ? A(m, n)   
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ? A1 zttmqr(k, nextm, n)
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ? A2 zttmqr(k, m,     n)

BODY
  void *p_elem_A = dague_private_memory_pop( p_work );

  DRYRUN(
  int tempkn = ((k)==((descA.mt)-1)) ? ((descA.m)-(k*(descA.mb))) : (descA.mb);
  int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
  int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
  int ldam = BLKLDD( descA, m );

  CORE_zunmqr(
      PlasmaLeft, PlasmaConjTrans, 
      tempmm, tempnn, MYMIN(tempmm, tempkn), ib, 
      A /* A(m, k) */, ldam, 
      T /* T(m, k) */, descT.mb, 
      C /* A(m, n) */, ldam, 
      p_elem_A, descT.nb );
      );
  dague_private_memory_push( p_work, p_elem_A );

  printlog("thread %d CORE_zunmqr(%d, %d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, tempmm, tempnn, min(tempmm, tempnn), ib, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, A(%d,%d)[%p], ldam, p_elem_A, descT.nb)\n",
           context->eu_id, k, m, n, m, k, A, m, k, T, m, n, C);

END


zttqrt(k, m)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  p =     inline_c %{ return currpiv(&descA, piv, m, k); %}
  nextp = inline_c %{ return nextpiv(&descA, piv, p, k, m); %}
  prevp = inline_c %{ return prevpiv(&descA, piv, p, k, m); %}
  prevm = inline_c %{ return prevpiv(&descA, piv, m, k, m); %}

  : A(m, k)

  /* A1 == A(p,  k) */
  /* A2 == A(m,  k) */
  /* T  == T2(m, k) */

  RW   A1 <- (   prevp == descA.mt ) ? A  zgeqrt(k, p ) : A1 zttqrt(k, prevp )
          -> (   nextp != descA.mt ) ? A1 zttqrt(k, nextp )
          -> ( ( nextp == descA.mt ) & (p == k) ) ? A(p, k)
          -> ( ( nextp == descA.mt ) & (p != k) ) ? A2 zttqrt(k, p)
  RW   A2 <- (   prevm == descA.mt ) ? A  zgeqrt(k, m ) : A1 zttqrt(k, prevm )
          -> A(m, k)
          -> (descA.nt-1 > k)? V zttmqr(k, m, (k+1)..(descA.nt-1))
  RW   T  <- T2(m, k)
          -> T2(m, k)
          -> (descA.nt-1 > k)? T zttmqr(k, m, (k+1)..(descA.nt-1))
BODY
  void *p_elem_A = dague_private_memory_pop( p_tau  );
  void *p_elem_B = dague_private_memory_pop( p_work );

  DRYRUN(
  int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
  int tempkn = ((k)==((descA.nt)-1)) ? ((descA.n)-(k*(descA.nb))) : (descA.nb);
  int ldam = BLKLDD( descA, m );

      CORE_zttqrt(
          tempmm, tempkn, ib, 
          A1 /* A(p, k) */, descA.mb, 
          A2 /* A(m, k) */, ldam, 
          T /* T(m, k) */, descT.mb, 
          p_elem_A, p_elem_B );
      );
  dague_private_memory_push( p_tau , p_elem_A );
  dague_private_memory_push( p_work, p_elem_B );

  printlog("thread %d CORE_zttqrt(%d, %d)\n\t(tempmm, tempkn, ib, A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, p_elem_B)\n",
  context->eu_id, k, m, p, k, A1, m, k, A2, m, k, T);

END

zttmqr(k, m, n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  p =     inline_c %{ return currpiv(&descA, piv, m, k); %}
  nextp = inline_c %{ return nextpiv(&descA, piv, p, k, m); %}
  prevp = inline_c %{ return prevpiv(&descA, piv, p, k, m); %}
  prevm = inline_c %{ return prevpiv(&descA, piv, m, k, m); %}

  : A(m, n)

  /* V  == A(m, k) */
  /* T  == T(m, k) */
  /* A1 == A(p, n) */
  /* A2 == A(m, n) */

  RW   A1 <- (   prevp == descA.mt ) ? C  zunmqr( k, p, n ) : A1 zttmqr(k, prevp, n )
          -> (   nextp != descA.mt ) ? A1 zttmqr( k, nextp, n)
          -> ( ( nextp == descA.mt ) & ( p == k ) ) ? A(p, n)
          -> ( ( nextp == descA.mt ) & ( p != k ) ) ? A2 zttmqr( k, p, n )
  RW   A2 <- (   prevm == descA.mt ) ? C zunmqr(k, m, n) : A1 zttmqr(k, prevm, n )
          -> ( n == k+1 ) ? A zgeqrt( k+1, m ) 
          -> ( n != k+1 ) ? C zunmqr( k+1, m, n )
  READ  V <- A2 zttqrt(k, m) 
  READ  T <- T  zttqrt(k, m) 

BODY
  void *p_elem_A;

  p_elem_A = dague_private_memory_pop( p_work );
  DRYRUN(

         int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
         int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
         int ldam = BLKLDD( descA, m );
         int ldwork = ib;
         
         CORE_zttmqr(
             PlasmaLeft, PlasmaConjTrans, 
             descA.mb, tempnn, tempmm, tempnn, descA.nb, ib, 
             A1 /* A(p, n) */, descA.mb, 
             A2 /* A(m, n) */, ldam, 
             V  /* A(m, k) */, ldam, 
             T  /* T(m, k) */, descT.mb, 
             p_elem_A, ldwork );
         );

  dague_private_memory_push( p_work, p_elem_A );

  printlog("thread %d CORE_zttmqr(%d, %d, %d)\n\t(PlasmaLeft, PlasmaConjTrans, descA.mb, tempnn, tempmm, tempnn, descA.nb, ib, A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, ldwork)\n",
           context->eu_id, k, m, n, p, n, A1, m, n, A2, m, k, V, m, k, T);

END
