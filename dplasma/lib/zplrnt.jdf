extern "C" %{
/*
 *  Copyright (c) 2010-2013
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include <core_blas.h>
#include <core_blas.h>


#include "dague.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/dplasmajdf.h"

%}

/*
 * Globals
 */
diagdom [type = "int" ]
seed    [type = "unsigned long long int" ]
descA   [type = "tiled_matrix_desc_t"]
A       [type = "dague_ddesc_t *"]

PLRNT(m, n)  [profile = off]

// Execution space
m = 0 .. descA.mt-1
n = 0 .. descA.nt-1

// Parallel partitioning
: A(m, n)

// Parameters

RW A <- A(m, n)
     -> A(m, n)
BODY
{
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
    int ldam = BLKLDD( descA, m );

#if !defined(DAGUE_DRY_RUN)
    CORE_zplrnt(
        tempmm, tempnn, A, ldam,
        descA.m, m*descA.mb, n*descA.nb, seed );

    if (diagdom && (m == n)) {
        dague_complex64_t  alpha;
        dague_complex64_t *lA = (dague_complex64_t*)A;
        int maxmn = dplasma_imax( descA.m, descA.n );
        int i;

#if defined(PRECISION_z) || defined(PRECISION_c)
        int nvir  = descA.m + descA.n - 1;
        alpha = (double)nvir + I * (double)maxmn;
#else
        alpha = maxmn;
#endif

        for(i=0; i<dplasma_imin(tempmm, tempnn); i++)
            lA[i * (ldam+1)] += alpha;
    }
#endif

    printlog("plrnt( %d, %d )\n"
             "    ( %d, %d, A(%d,%d), %d, %d, %d, %d, %llu)\n",
             m, n, tempmm, tempnn,
             m, n, ldam,
             descA.m, m*descA.mb, n*descA.nb, seed);
}
END

extern "C" %{

%}
