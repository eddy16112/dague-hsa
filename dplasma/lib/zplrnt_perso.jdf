extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#define pi (3.1415926535897932384626433832795028841971693992)

#include <math.h>
#include <core_blas.h>
#include <core_blas.h>

#include "dague.h"
#include "dplasma.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/dplasmajdf.h"

static inline int dague_imin(int a, int b);

void CORE_zplrnt_perso( enum matrix_init_e type,
                        int M, int N, dague_complex64_t *A, int LDA,
                        int gM, int gN, int m0, int n0,
                        unsigned long long int seed )
{
    int i, j;

    switch( type ) {
    case MATRIX_RANDOM:
    {
        CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );
    }
    break;

    case MATRIX_HADAMARD:
    {
        int tmp = gM;
        int nbone;
        while ( tmp > 1 ) {
            if( tmp % 2 != 0 ) {
                fprintf(stderr, "The Hadamard matrix cannot be initialized on matrices which are not 2**k - by - 2**k\n");
                exit(-1);
            }
            tmp /= 2;
        }

        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                tmp = ((m0 + i) & (n0 + j));
                nbone = 0;
                while ( tmp != 0 )
                {
                    nbone += ( tmp & 1 );
                    tmp >>= 1;
                }
                A[j*LDA+i] = (dague_complex64_t)(1. - 2. * ( nbone % 2 ));
            }
        }
    }
    break;

    case MATRIX_PARTER:
    {
        if ( gM != gN ) {
            fprintf(stderr, "Parter Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( .5 + m0 - n0 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i - j );
            }
        }
    }
    break;

    case MATRIX_RIS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "RIS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( gM - m0 - n0 - 0.5 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t).5 / (dague_complex64_t)( tmp - i - j );
            }
        }
    }
    break;

    case MATRIX_KMS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "KMS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t rho = .5;
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)( cpow( rho, fabs( (double)( m0 + i - n0 - j ) ) ) );
            }
        }
    }
    break;

    case MATRIX_MOLER:
    {
        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                if ( ii == jj ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii + 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( dague_imin( ii, jj ) - 1. );
                }
            }
        }
    }
    break;

    case MATRIX_RIEMANN:
    {
        int ii, jj;
        for (j=0,jj=n0+2; j<N; j++,jj++) {
            for (i=0,ii=m0+2; i<M; i++,ii++) {
                if ( jj%ii == 0 ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii - 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -1. );
                }
            }
        }
    }
    break;

    case MATRIX_LEHMER:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj >= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii ) / (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( jj ) / (dague_complex64_t)( ii );
                }
            }
        }
    }
    break;

    case MATRIX_MINIJ:
    {
        if ( gM != gN ) {
            fprintf(stderr, "MinIJ Matrix requires square matrices\n");
            exit(-1);
        }

        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t) dague_imin( ii, jj );
            }
        }
    }
    break;

    /* case MATRIX_DORR: */
    /* { */
    /*     dague_complex64_t theta = 0.01; */
    /*     dague_complex64_t h     = 1. / ( gN + 1. ); */
    /*     dague_complex64_t term  = theta / ( h * h ); */

    /*     LAPACKE_zlaset_work(LAPACK_COL_MAJOR, 'A', M, N, 0., 0., A, LDA); */

    /*     int ii, jj; */
    /*     for (j=0,jj=n0+1; j<N; j++,jj++) { */
    /*         for (i=0,ii=m0+1; i<M; i++,ii++) { */
    /*             A[j*LDA+i] = (dague_complex64_t)( 1. ) / (dague_complex64_t)( ii+jj ); */
    /*         } */
    /*     } */
    /* } */
    /* break; */

    case MATRIX_DEMMEL:
    {
        dague_complex64_t dii;
        int ii, jj;

        /* Randomize the marix as usual */
        CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );

        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                dii = cpow( 10. , 14. * ii / gM );
                A[j*LDA+i] *= dii * ( (jj == ii) ? 1. : 1.e-7 );
            }
        }
    }
    break;

    case MATRIX_INVHESS:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj <= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -ii );
                }
            }
        }
    }
    break;

    case MATRIX_CAUCHY:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t)( 1. ) / (dague_complex64_t)( ii+jj );
            }
        }
    }
    break;

    case MATRIX_HILB:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
            }
        }
    }
    break;

    case MATRIX_LOTKIN:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        if (m0 == 0) {
            for (j=0; j<N; j++) {
                A[j*LDA] = (dague_complex64_t)1.;
                for (i=1; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        } else {
            for (j=0; j<N; j++) {
                for (i=0; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        }
    }
    break;

    case MATRIX_ORTHOGO: /* Default: k=1 */
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = dplasma_zsqrt( 2. / (gN+1.) ) * (dague_complex64_t) sin( (double)ii*(double)jj*pi / (double)gN );
            }
        }
    }
    break;

    case MATRIX_WILKINSON:
    {
        if ( gM != gN ) {
            fprintf(stderr, "Wilkinson Matrix requires square matrices\n");
            exit(-1);
        }

        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                if (ii == jj) {
                    dague_complex64_t tmp = (dague_complex64_t)(( (gN - 1 - ii) < ii ) ? gN - 1 - ii : ii );
                     A[j*LDA+i] = (dague_complex64_t)(gN - 2. * tmp - 1.) / 2.;
                }
                else if ( (ii == jj+1) || (ii == jj-1) ) {
                     A[j*LDA+i] = (dague_complex64_t)1.;
                }
                else {
                     A[j*LDA+i] = (dague_complex64_t)0.;
                }
           }
       }
    }
    break;

    case MATRIX_FOSTER: /* Default: k=h=c=1 */
    {
        double k=1., h=1., c=1.;

        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {

                if (ii == jj) {
                    if (jj == 0)
                        A[j*LDA+i] = (dague_complex64_t)1.;
                    else if (jj == gN-1)
                        A[j*LDA+i] = (dague_complex64_t)(1. - (1. / c) - (k*h)/2. );
                    else
                        A[j*LDA+i] = (dague_complex64_t)(1. - (k*h)/2. );
                }
                else if (jj == 0) {
                    A[j*LDA+i] = (dague_complex64_t)(-k*h/2.);
                }
                else if (jj == gN-1) {
                    A[j*LDA+i] = (dague_complex64_t)(-1./c);
                }
                else if (ii > jj) {
                    A[j*LDA+i] = (dague_complex64_t)(-k*h);
                }
                else {
                    A[j*LDA+i] = (dague_complex64_t)0.;
                }
            }
        }
    }
    break;

    case MATRIX_WRIGHT: /*Default: h=0.01, M=[-10 -19, 19 30]. Then exp(h*M)=[0.9048 0.8270, 1.2092 1.3499] */
    {
        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {

                if (ii == jj)
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else if ((ii == jj + 2) && (jj % 2 == 0))
                    A[j*LDA+i] = (dague_complex64_t)(-0.9048);
                else if ((ii == jj + 3) && (jj % 2 == 0))
                    A[j*LDA+i] = (dague_complex64_t)(-1.2092);
                else if ((ii == jj + 2) && (jj % 2 == 1))
                    A[j*LDA+i] = (dague_complex64_t)(-0.8270);
                else if ((ii == jj + 3) && (jj % 2 == 1))
                    A[j*LDA+i] = (dague_complex64_t)(-1.3499);
                else if ((jj == gM-2) && (ii == 0))
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else if ((jj == gM-1) && (ii == 1))
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else
                    A[j*LDA+i] = (dague_complex64_t)0.;
            }
        }
    }
    break;

    case MATRIX_LANGOU:
    {
         CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );

         int ii, jj;
         //if (((m0 >= gM /4)&&(m0 < gM /2)&&(n0<gN /2)) || ((m0<gM /2)&&(n0>=gN/4)&&(n0<gN/2)))
         //if ((n0 >= gN/4)&&(n0<gN/2))
         if ((n0>=gN/4)&&(n0<gN/2)&&(m0>=n0))
            for (j=0,jj=n0; j<N; j++,jj++) {
                for (i=0,ii=m0; i<M; i++,ii++) {
                    A[j*LDA+i] = (dague_complex64_t)(0.0000000000000001) * A[j*LDA+i];
                    //printf("A[%d] = %f\n",j*LDA+i,A[j*LDA+i]);
                }
            }
    }
    break;

    default:
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1.;
            }
        }

        if ( m0 == n0 ) {
            for (i=0; i< dague_imin(M, N); i++) {
                A[i*LDA+i] = (dague_complex64_t)10.;
            }
        }
    }
}
%}

/*
 * Globals
 */
mtype  [type = "enum matrix_init_e" ]
seed   [type = "unsigned long long int" ]
dataA  [type = "dague_ddesc_t *"]
descA  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA)"]

PLRNT_PERSO(m, n)  [profile = off]

// Execution space
m = 0 .. descA.mt-1
n = 0 .. descA.nt-1

// Parallel partitioning
: dataA(m, n)

// Parameters

RW A <- dataA(m, n)
     -> dataA(m, n)
BODY
{
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
    int ldam = BLKLDD( descA, m );
    int m0 = m*descA.mb;
    int n0 = n*descA.nb;

    DRYRUN(
        CORE_zplrnt_perso(
            mtype, tempmm, tempnn, A, ldam,
            descA.m, descA.n, m0, n0, seed );
           );

    printlog("zplrnt_perso( %d, %d )\n"
             "    ( %d, %d, A(%d,%d), %d, %d, %d, %d, %d)\n",
             m, n, tempmm, tempnn,
             m, n, ldam,
             descA.m, m0, n0, 1);
}
END

extern "C" %{

%}
