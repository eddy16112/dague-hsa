extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#define pi (3.1415926535897932384626433832795028841971693992)

#include <math.h>
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "dplasma.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/dplasmajdf.h"

static inline int dague_imin(int a, int b);

void CORE_zplrnt_perso( enum matrix_init_e type,
                        int M, int N, dague_complex64_t *A, int LDA,
                        int gM, int gN, int m0, int n0,
                        unsigned long long int seed )
{
    int i, j;

    switch( type ) {
    case MATRIX_RANDOM:
    {
        CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );
    }
    break;

    case MATRIX_HADAMARD:
    {
        int tmp = gM;
        int nbone;
        while ( tmp > 1 ) {
            if( tmp % 2 != 0 ) {
                fprintf(stderr, "The Hadamard matrix cannot be initialized on matrices which are not 2**k - by - 2**k\n");
                exit(-1);
            }
            tmp /= 2;
        }

        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                tmp = ((m0 + i) & (n0 + j));
                nbone = 0;
                while ( tmp != 0 )
                {
                    nbone += ( tmp & 1 );
                    tmp >>= 1;
                }
                A[j*LDA+i] = (dague_complex64_t)(1. - 2. * ( nbone % 2 ));
            }
        }
    }
    break;

    case MATRIX_PARTER:
    {
        if ( gM != gN ) {
            fprintf(stderr, "Parter Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( .5 + m0 - n0 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i - j );
            }
        }
    }
    break;

    case MATRIX_RIS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "RIS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( gM - m0 - n0 - 0.5 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t).5 / (dague_complex64_t)( tmp - i - j );
            }
        }
    }
    break;

    case MATRIX_KMS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "KMS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t rho = .5;
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)( cpow( rho, fabs( (double)( m0 + i - n0 - j ) ) ) );
            }
        }
    }
    break;

    case MATRIX_MOLER:
    {
        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                if ( ii == jj ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii + 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( dague_imin( ii, jj ) - 1. );
                }
            }
        }
    }
    break;

    case MATRIX_CIRCUL:
    {
        dague_complex64_t *lA = A;
        int jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            if ( m0 >= jj ) {
                CORE_zplrnt( M, 1, lA, LDA, gM, m0 - jj, 0, seed );
            }
            else if ( (m0 + M) <= jj ) {
                CORE_zplrnt( M, 1, lA, LDA, gM, (gM + m0 - jj) % gM, 0, seed );
            } else {
                assert( jj - m0 + M - j == M );
                assert( jj - m0 > 0 );
                assert( M - j > 0 );

                /* Over the diagonal */
                CORE_zplrnt( jj - m0, 1, lA, LDA, gM, (gM + m0 - jj) % gM, 0, seed );
                /* Under the diagonal */
                CORE_zplrnt( M - j, 1, lA + (jj - m0), LDA, gM, 0, 0, seed );
            }
            lA += LDA;
        }
    }
    break;

    case MATRIX_HANKEL:
    {
        dague_complex64_t *lA = A;
        unsigned long long int seedc = seed;
        unsigned long long int seedr = seed + 17; /* 17 is a complete arbitrary choice */

        int jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            /* Upper Left triangle */
            if ( (m0 + M + jj) <= gM ) {
                CORE_zplrnt( M, 1, lA, LDA, gM, m0 + jj, 0, seedc );
            }
            /* Lower Right triangle */
            else if ( m0 > (gM-jj-1) ) {
                CORE_zplrnt( M, 1, lA, LDA, gM, m0 - gM + jj + 1, 0, seedr );
            }
            /* Covering the SW-NE diagonal */
            else {
                /* Rows before gN - jj included  */
                CORE_zplrnt( gM - jj - m0, 1, lA, LDA, gM, jj+m0, 0, seedc );
                /* Rows after gN -jj excluded */
                CORE_zplrnt( M + jj + m0 - gM, 1, lA + gM-jj-m0, LDA, gM, 1, 0, seedr );
            }
            lA += LDA;
        }
    }
    break;

    case MATRIX_COMPAN:
    {
        /* Initialize the matrix to 0 */
        CORE_zlaset( PlasmaUpperLower, M, N, 0., 0., A, LDA );

        /* Initialize first row */
        if (m0 == 0) {
            dague_complex64_t alpha;

            /* Get U(0) */
            CORE_zplrnt( 1, 1, &alpha, 1, 1, 1, 0, seed );
            alpha = 1. / alpha;

            /* Init first row */
            CORE_zplrnt( 1, N, A, LDA, 1, n0+2, 0, seed );
            cblas_zscal(N, CBLAS_SADDR(alpha), A, LDA);
        }

        /* Initialize the subdiagonal */
        {
            int ii, jj;
            for (j=0,jj=n0+1; j<N; j++,jj++) {
                for (i=0,ii=m0; i<M; i++,ii++) {
                    if ( ii == jj )
                        A[j*LDA+i] = (dague_complex64_t)( 1. );
                }
            }
        }
    }
    break;

    case MATRIX_RIEMANN:
    {
        int ii, jj;
        for (j=0,jj=n0+2; j<N; j++,jj++) {
            for (i=0,ii=m0+2; i<M; i++,ii++) {
                if ( jj%ii == 0 ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii - 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -1. );
                }
            }
        }
    }
    break;

    case MATRIX_LEHMER:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj >= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii ) / (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( jj ) / (dague_complex64_t)( ii );
                }
            }
        }
    }
    break;

    case MATRIX_MINIJ:
    {
        if ( gM != gN ) {
            fprintf(stderr, "MinIJ Matrix requires square matrices\n");
            exit(-1);
        }

        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t) dague_imin( ii, jj );
            }
        }
    }
    break;

    case MATRIX_DORR:
    {
        dague_complex64_t theta = 0.01;
        dague_complex64_t h     = 1. / ( gN + 1. );
        dague_complex64_t term  = theta / ( h * h );
        int gN_2 = (gN+1) / 2;
        int ii, jj;

        CORE_zlaset( PlasmaUpperLower, M, N, 0., 0., A, LDA );

        /* First half */
        for (j=0,jj=n0; j<N && jj<gN_2; j++,jj++) {
            if ( ( m0 <= jj+1 ) && ( (m0+M) > (jj-1) ) ) {
                for (i=0,ii=m0; i<M; i++,ii++) {
                    if ( ii == jj-1 ) {
                        A[j*LDA+i] = - term - ( 0.5 - jj * h ) / h;
                    }
                    else if (ii == jj) {
                        A[j*LDA+i] = 2. * term + ( 0.5 - (1.+jj)*h ) / h;
                    }
                    else if (ii == jj+1 ) {
                        A[j*LDA+i] = - term;
                        if (jj+1 == gN_2 )
                            A[j*LDA+i] =  - term + ( 0.5 - (2.+jj) * h ) / h;
                        break;
                    }
                }
            }
        }

        /* Second half */
        /* Star with exit of the first loop */
        for (; j<N; j++,jj++) {
            if ( ( m0 <= jj+1 ) && ( (m0+M) > (jj-1) ) ) {
                for (i=0,ii=m0; i<M; i++,ii++) {
                    if ( ii == jj-1 ) {
                        A[j*LDA+i] = - term;
                        if ( jj == gN_2 )
                            A[j*LDA+i] = - term - ( 0.5 - jj * h ) / h;
                    }
                    else if (ii == jj) {
                        A[j*LDA+i] = 2. * term - ( 0.5 - (1.+jj)*h ) / h;
                    }
                    else if (ii == jj+1 ) {
                        A[j*LDA+i] = - term + ( 0.5 - (2.+jj) * h ) / h;
                        break;
                    }
                }
            }
        }
    }
    break;

    case MATRIX_DEMMEL:
    {
        dague_complex64_t dii;
        int ii, jj;

        /* Randomize the marix as usual */
        CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );

        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                dii = cpow( 10. , 14. * ii / gM );
                A[j*LDA+i] *= dii * ( (jj == ii) ? 1. : 1.e-7 );
            }
        }
    }
    break;

    case MATRIX_CHEBVAND:
    {
        dague_complex64_t p, u_0, u_1, u_2;
        int ii, jj;

        /* Randomize the marix as usual */
        for (j=0,jj=n0; j<N; j++,jj++) {
            i=0; ii=0;
            p = (dague_complex64_t)jj / (dague_complex64_t)(gN - 1.);
            u_0 = 1.;
            u_1 = p;

            if ( m0 == 0 ) {
                A[j*LDA] = u_0;
                i++; ii++;

                if ( i<M ) {
                    A[j*LDA+1] = u_1;
                    i++; ii++;
                }
            }
            else if ( m0 == 1 ) {
                A[j*LDA] = u_1;
                i++; ii++;
            }
            else {
                ii = 2;
            }

            for(;ii<m0;ii++) {
                u_2 = 2. * p * u_1 - u_0;
                u_0 = u_1;
                u_1 = u_2;
            }

            for (; i<M; i++) {
                u_2 = 2. * p * u_1 - u_0;
                u_0 = u_1;
                u_1 = u_2;
                A[j*LDA+i] = u_2;
            }
        }
    }
    break;

    case MATRIX_INVHESS:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj <= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -ii );
                }
            }
        }
    }
    break;

    case MATRIX_PROLATE:
    {
        dague_complex64_t w = 0.25;
        int ii, jj, kk;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                kk = abs( ii - jj );
                if (kk == 0 ) {
                    A[j*LDA+i] = (dague_complex64_t)( 2. * w );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( sin( 2. * pi * w * kk ) / ( pi * kk ) );
                }
            }
        }
    }
    break;

    case MATRIX_CAUCHY:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t)( 1. ) / (dague_complex64_t)( ii+jj );
            }
        }
    }
    break;

    case MATRIX_HILB:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
            }
        }
    }
    break;

    case MATRIX_LOTKIN:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        if (m0 == 0) {
            for (j=0; j<N; j++) {
                A[j*LDA] = (dague_complex64_t)1.;
                for (i=1; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        } else {
            for (j=0; j<N; j++) {
                for (i=0; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        }
    }
    break;

    case MATRIX_ORTHOGO: /* Default: k=1 */
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = dplasma_zsqrt( 2. / (gN+1.) ) * (dague_complex64_t) sin( (double)ii*(double)jj*pi / (double)gN );
            }
        }
    }
    break;

    case MATRIX_WILKINSON:
    {
        if ( gM != gN ) {
            fprintf(stderr, "Wilkinson Matrix requires square matrices\n");
            exit(-1);
        }

        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                if (ii == jj) {
                    dague_complex64_t tmp = (dague_complex64_t)(( (gN - 1 - ii) < ii ) ? gN - 1 - ii : ii );
                    A[j*LDA+i] = (dague_complex64_t)(gN - 2. * tmp - 1.) / 2.;
                }
                else if ( (ii == jj+1) || (ii == jj-1) ) {
                    A[j*LDA+i] = (dague_complex64_t)1.;
                }
                else {
                    A[j*LDA+i] = (dague_complex64_t)0.;
                }
            }
        }
    }
    break;

    case MATRIX_FOSTER: /* Default: k=h=c=1 */
    {
        double k=1., h=1., c=1.;

        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {

                if (ii == jj) {
                    if (jj == 0)
                        A[j*LDA+i] = (dague_complex64_t)1.;
                    else if (jj == gN-1)
                        A[j*LDA+i] = (dague_complex64_t)(1. - (1. / c) - (k*h)/2. );
                    else
                        A[j*LDA+i] = (dague_complex64_t)(1. - (k*h)/2. );
                }
                else if (jj == 0) {
                    A[j*LDA+i] = (dague_complex64_t)(-k*h/2.);
                }
                else if (jj == gN-1) {
                    A[j*LDA+i] = (dague_complex64_t)(-1./c);
                }
                else if (ii > jj) {
                    A[j*LDA+i] = (dague_complex64_t)(-k*h);
                }
                else {
                    A[j*LDA+i] = (dague_complex64_t)0.;
                }
            }
        }
    }
    break;

    case MATRIX_WRIGHT: /*Default: h=0.01, M=[-10 -19, 19 30]. Then exp(h*M)=[0.9048 0.8270, 1.2092 1.3499] */
    {
        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {

                if (ii == jj)
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else if ((ii == jj + 2) && (jj % 2 == 0))
                    A[j*LDA+i] = (dague_complex64_t)(-0.9048);
                else if ((ii == jj + 3) && (jj % 2 == 0))
                    A[j*LDA+i] = (dague_complex64_t)(-1.2092);
                else if ((ii == jj + 2) && (jj % 2 == 1))
                    A[j*LDA+i] = (dague_complex64_t)(-0.8270);
                else if ((ii == jj + 3) && (jj % 2 == 1))
                    A[j*LDA+i] = (dague_complex64_t)(-1.3499);
                else if ((jj == gM-2) && (ii == 0))
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else if ((jj == gM-1) && (ii == 1))
                    A[j*LDA+i] = (dague_complex64_t)1.;
                else
                    A[j*LDA+i] = (dague_complex64_t)0.;
            }
        }
    }
    break;

    default:
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1.;
            }
        }

        if ( m0 == n0 ) {
            for (i=0; i< dague_imin(M, N); i++) {
                A[i*LDA+i] = (dague_complex64_t)10.;
            }
        }
    }
}
%}

/*
 * Globals
 */
type   [type = "enum matrix_init_e" ]
seed   [type = "unsigned long long int" ]
dataA  [type = "dague_ddesc_t *"]
descA  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA)"]

PLRNT_PERSO(m, n)  [profile = off]

// Execution space
m = 0 .. descA.mt-1
n = 0 .. descA.nt-1

// Parallel partitioning
: dataA(m, n)

// Parameters

RW A <- dataA(m, n)
     -> dataA(m, n)
BODY
{
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
    int ldam = BLKLDD( descA, m );
    int m0 = m*descA.mb;
    int n0 = n*descA.nb;

    DRYRUN(
        CORE_zplrnt_perso(
            type, tempmm, tempnn, A, ldam,
            descA.m, descA.n, m0, n0, seed );
           );

    printlog("zplrnt_perso( %d, %d )\n"
             "    ( %d, %d, A(%d,%d), %d, %d, %d, %d, %d)\n",
             m, n, tempmm, tempnn,
             m, n, ldam,
             descA.m, m0, n0, 1);
}
END

extern "C" %{

%}
