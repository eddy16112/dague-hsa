extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#define pi (3.1415926535897932384626433832795028841971693992)

#include <math.h>
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "dplasma.h"
#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/dplasmajdf.h"

#define MATRIX_HADAMARD 1
#define MATRIX_PARTER   3
#define MATRIX_RIS      4
#define MATRIX_KMS      5
#define MATRIX_MOLER    8
#define MATRIX_RIEMANN  18
#define MATRIX_LEHMER   22
#define MATRIX_MINIJ    24
#define MATRIX_DEMMEL   29
#define MATRIX_INVHESS  31
#define MATRIX_CAUCHY   34
#define MATRIX_HILBERT  35
#define MATRIX_LOTKIN   36
#define MATRIX_ORTHOGO  38

static inline int dague_imin(int a, int b);

void CORE_zplrnt_perso( int M, int N, dague_complex64_t *A, int LDA,
                        int gM, int gN, int m0, int n0, int type,
                        unsigned long long int seed )
{
    int i, j;

    switch( type ) {
    case MATRIX_HADAMARD:
    {
        int tmp = gM;
        int nbone;
        while ( tmp > 1 ) {
            if( tmp % 2 != 0 ) {
                fprintf(stderr, "The Hadamard matrix cannot be initialized on matrices which are not 2**k - by - 2**k\n");
                exit(-1);
            }
            tmp /= 2;
        }

        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                tmp = ((m0 + i) & (n0 + j));
                nbone = 0;
                while ( tmp != 0 )
                {
                    nbone += ( tmp & 1 );
                    tmp >>= 1;
                }
                A[j*LDA+i] = (dague_complex64_t)(1. - 2. * ( nbone % 2 ));
            }
        }
    }
    break;

    case MATRIX_PARTER:
    {
        if ( gM != gN ) {
            fprintf(stderr, "Parter Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( .5 + m0 - n0 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i - j );
            }
        }
    }
    break;

    case MATRIX_RIS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "RIS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t tmp = (dague_complex64_t)( gM - m0 - n0 - 0.5 );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t).5 / (dague_complex64_t)( tmp - i - j );
            }
        }
    }
    break;

    case MATRIX_KMS:
    {
        if ( gM != gN ) {
            fprintf(stderr, "KMS Matrix requires square matrices\n");
            exit(-1);
        }

        dague_complex64_t rho = .5;
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)( cpow( rho, fabs( (double)( m0 + i - n0 - j ) ) ) );
            }
        }
    }
    break;

    case MATRIX_MOLER:
    {
        int ii, jj;
        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                if ( ii == jj ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii + 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( dague_imin( ii, jj ) - 1. );
                }
            }
        }
    }
    break;

    case MATRIX_RIEMANN:
    {
        int ii, jj;
        for (j=0,jj=n0+2; j<N; j++,jj++) {
            for (i=0,ii=m0+2; i<M; i++,ii++) {
                if ( jj%ii == 0 ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii - 1. );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -1. );
                }
            }
        }
    }
    break;

    case MATRIX_LEHMER:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj >= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( ii ) / (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( jj ) / (dague_complex64_t)( ii );
                }
            }
        }
    }
    break;

    case MATRIX_MINIJ:
    {
        if ( gM != gN ) {
            fprintf(stderr, "MinIJ Matrix requires square matrices\n");
            exit(-1);
        }

        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t) dague_imin( ii, jj );
            }
        }
    }
    break;

    /* case MATRIX_DORR: */
    /* { */
    /*     dague_complex64_t theta = 0.01; */
    /*     dague_complex64_t h     = 1. / ( gN + 1. ); */
    /*     dague_complex64_t term  = theta / ( h * h ); */

    /*     LAPACKE_zlaset_work(LAPACK_COL_MAJOR, 'A', M, N, 0., 0., A, LDA); */

    /*     int ii, jj; */
    /*     for (j=0,jj=n0+1; j<N; j++,jj++) { */
    /*         for (i=0,ii=m0+1; i<M; i++,ii++) { */
    /*             A[j*LDA+i] = (dague_complex64_t)( 1. ) / (dague_complex64_t)( ii+jj ); */
    /*         } */
    /*     } */
    /* } */
    /* break; */

    case MATRIX_DEMMEL:
    {
        dague_complex64_t dii;
        int ii, jj;

        /* Randomize the marix as usual */
        CORE_zplrnt( M, N, A, LDA, gM, m0, n0, seed );

        for (j=0,jj=n0; j<N; j++,jj++) {
            for (i=0,ii=m0; i<M; i++,ii++) {
                dii = cpow( 10. , 14. * ii / gM );
                A[j*LDA+i] *= dii * ( (jj == ii) ? 1. : 1.e-7 );
            }
        }
    }
    break;

    case MATRIX_INVHESS:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                if ( jj <= ii ) {
                    A[j*LDA+i] = (dague_complex64_t)( jj );
                } else {
                    A[j*LDA+i] = (dague_complex64_t)( -ii );
                }
            }
        }
    }
    break;

    case MATRIX_CAUCHY:
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = (dague_complex64_t)( 1. ) / (dague_complex64_t)( ii+jj );
            }
        }
    }
    break;

    case MATRIX_HILBERT:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
            }
        }
    }
    break;

    case MATRIX_LOTKIN:
    {
        dague_complex64_t tmp = (dague_complex64_t)( m0 + n0 + 1. );
        if (m0 == 0) {
            for (j=0; j<N; j++) {
                A[j*LDA] = (dague_complex64_t)1.;
                for (i=1; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        } else {
            for (j=0; j<N; j++) {
                for (i=0; i<M; i++) {
                    A[j*LDA+i] = (dague_complex64_t)1. / (dague_complex64_t)( tmp + i + j );
                }
            }
        }
    }
    break;

    case MATRIX_ORTHOGO: /* Default: k=1 */
    {
        int ii, jj;
        for (j=0,jj=n0+1; j<N; j++,jj++) {
            for (i=0,ii=m0+1; i<M; i++,ii++) {
                A[j*LDA+i] = dplasma_zsqrt( 2. / (gN+1.) ) * (dague_complex64_t) sin( (double)ii*(double)jj*pi / (double)gN );
            }
        }
    }
    break;

    default:
        for (j=0; j<N; j++) {
            for (i=0; i<M; i++) {
                A[j*LDA+i] = (dague_complex64_t)1.;
            }
        }

        if ( m0 == n0 ) {
            for (i=0; i< dague_imin(M, N); i++) {
                A[i*LDA+i] = (dague_complex64_t)10.;
            }
        }
    }
}
%}

/*
 * Globals
 */
seed   [type = "unsigned long long int" ]
descA  [type = "tiled_matrix_desc_t"]
A      [type = "dague_ddesc_t *"]

PLRNT_PERSO(m, n)  [profile = off]

// Execution space
m = 0 .. descA.mt-1
n = 0 .. descA.nt-1

// Parallel partitioning
: A(m, n)

// Parameters

RW A <- A(m, n)
     -> A(m, n)
BODY
{
    int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
    int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
    int ldam = BLKLDD( descA, m );
    int m0 = m*descA.mb;
    int n0 = n*descA.nb;

    DRYRUN(
        CORE_zplrnt_perso(
            tempmm, tempnn, A, ldam,
            descA.m, descA.n, m0, n0,
            MATRIX_HADAMARD, seed );
           );

    printlog("zplrnt_perso( %d, %d )\n"
             "    ( %d, %d, A(%d,%d), %d, %d, %d, %d, %d)\n",
             m, n, tempmm, tempnn,
             m, n, ldam,
             descA.m, m0, n0, 1);
}
END

extern "C" %{

%}
