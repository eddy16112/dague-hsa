extern "C" %{
/*
 *  Copyright (c) 2010-2013
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/matrix.h"

#if defined(HAVE_CUDA)
#include <dague/devices/cuda/dev_cuda.h>
#include "dplasma/cores/cuda_zgemm.h"
extern int *gpu_counter;
#endif  /* defined(HAVE_CUDA) */
%}

/*
 * Globals
 */
transA [type = int]
transB [type = int]

alpha  [type = dague_complex64_t]
beta   [type = dague_complex64_t]

dataA  [type = "dague_ddesc_t *"]
descA  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataA)"]
Adist  [type = "dague_ddesc_t *" aligned = A]
dataB  [type = "dague_ddesc_t *"]
descB  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataB)"]
Bdist  [type = "dague_ddesc_t *" aligned = B]
dataC  [type = "dague_ddesc_t *"]
descC  [type = "tiled_matrix_desc_t" hidden = on default = "*((tiled_matrix_desc_t*)dataC)"]
P      [type = "int" ]
Q      [type = "int" ]

/**************************************************
 *                       READ_A                   *
 **************************************************/
READ_A(m, k, q)  [profile = off]

m = 0 .. descA.mt-1
k = 0 .. descA.nt-1
q = 0 .. Q-1
first = inline_c %{ return  k % Q; %}
prev  = inline_c %{ return (q + Q - 1) % Q; %}
next  = inline_c %{ return (q     + 1) % Q; %}

: Adist(m, q)

READ A <- (q    == first) ? dataA(m, k) : A READ_A(m, k, prev)
       -> (next != first) ? A READ_A(m, k, next)
       -> A GEMM(m, q .. descA.nt-1 .. Q, k)

CTL ctl <- (k != descA.nt-1) ? ctl READ_A( m, k+1, q )
        -> (k != 0         ) ? ctl READ_A( m, k-1, q )
BODY
{
    printlog("rank %u <- A(%d,%d)\n", __dague_handle->super.dataA->myrank, m, k);
}
END

/**************************************************
 *                       READ_B                   *
 **************************************************/
READ_B(k, n, p)  [profile = off]

k = 0 .. descB.mt-1
n = 0 .. descB.nt-1
p = 0 .. P-1
first = inline_c %{ return  k % P; %}
prev  = inline_c %{ return (p + P - 1) % P; %}
next  = inline_c %{ return (p     + 1) % P; %}

: Bdist(p, n)

READ B <- (p    == first) ? dataB(k, n) : B READ_B(k, n, prev)
       -> (next != first) ? B READ_B(k, n, next)
       -> B GEMM(p .. descA.mt-1 .. P, n, k)

CTL ctl <- (k != descB.mt-1) ? ctl READ_B( k+1, n, p )
        -> (k != 0         ) ? ctl READ_B( k-1, n, p )

BODY
{
     printlog("rank %u <- B(%d,%d)\n", __dague_handle->super.dataB->myrank, k, n);
}
END

/**************************************************
 *                       GEMM                     *
 **************************************************/
GEMM(m, n, k)

// Execution space
m = 0 .. descC.mt-1
n = 0 .. descC.nt-1
k = 0 .. descA.nt-1

p  = inline_c %{ return m % P; %}
q  = inline_c %{ return n % Q; %}

// Parallel partitioning
: dataC(m, n)

// Parameters
READ A <- A READ_A(m, k, q)
READ B <- B READ_B(k, n, p)

RW   C <- (k == descA.nt-1) ? dataC(m, n) : C GEMM( m, n, k+1 )
       -> (k == 0         ) ? dataC(m, n) : C GEMM( m, n, k-1 )

BODY [type=CUDA dyld=cublasZgemm]
{
    dague_complex64_t lbeta = (k == descA.nt-1) ? beta : (dague_complex64_t)1.0;
    int tempmm = m == descC.mt-1 ? descC.m - m * descC.mb : descC.mb;
    int tempnn = n == descC.nt-1 ? descC.n - n * descC.nb : descC.nb;
    int tempkk = k == descA.nt-1 ? descA.n - k * descA.nb : descA.nb;
    int ldam = BLKLDD(descA, m);
    int ldbk = BLKLDD(descB, k);
    int ldcm = BLKLDD(descC, m);

    return gpu_zgemm(context, this_task,
                     ( k == descA.nt-1 ),
                     transA, transB,
                     tempmm, tempnn, tempkk,
                     alpha, ldam,
                     ldbk,
                     lbeta, ldcm);
}
END

BODY
{
    dague_complex64_t lbeta = (k == descA.nt-1) ? beta : (dague_complex64_t)1.0;
    int tempmm = m == descC.mt-1 ? descC.m - m * descC.mb : descC.mb;
    int tempnn = n == descC.nt-1 ? descC.n - n * descC.nb : descC.nb;
    int tempkk = k == descA.nt-1 ? descA.n - k * descA.nb : descA.nb;
    int ldam = BLKLDD(descA, m);
    int ldbk = BLKLDD(descB, k);
    int ldcm = BLKLDD(descC, m);

#if !defined(DAGUE_DRY_RUN)
    CORE_zgemm(transA, transB,
               tempmm, tempnn, tempkk,
               alpha, A /*A(m, k)*/, ldam,
                      B /*B(k, n)*/, ldbk,
               lbeta, C /*C(m, n)*/, ldcm);
#endif  /* !defined(DAGUE_DRY_RUN) */

    printlog("gemm( %d, %d, %d )\n"
             "    ( %s, %s, %d, %d, %d, %f, A(%d,%d), %d, B(%d,%d), %d, %f, C(%d,%d), %d)\n",
             m, n, k,
             plasma_const( transA ), plasma_const( transB ),
             tempmm, tempnn, tempkk,
             creal(alpha), m, k, ldam,
                           k, n, ldbk,
             creal(lbeta), m, n, ldcm );
}
END
