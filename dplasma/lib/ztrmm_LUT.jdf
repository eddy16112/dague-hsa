extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
  
#include <plasma.h>
#include <core_blas.h>

#include "dague.h"
#include "data_distribution.h"
#include "dplasmajdf.h"

%}

/* Globals
 * GRIDrows, GRIDcols, NB, SIZE
 */
Amb  [int]
Anb  [int]
Amt  [int]
Ant  [int]
Am   [int]
An   [int]

Bmb  [int]
Bnb  [int]
Bmt  [int]
Bnt  [int]
Bm   [int]
Bn   [int]
     
side [int]
uplo [int]
trans[int]
diag [int]

alpha[Dague_Complex64_t]

/**************************************************
 *                      TRMM                      *
 **************************************************/
TRMM_IN(m)
m = 0..Bmt-1

:A(m, m)

READ A <- A(m, m)
       -> A TRMM(m, 0..Bnt-1)

BODY
 /* Nothing */
END

TRMM(m, n)

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1

// Parallel partitioning
: B(m, n)

// Parameters
READ  A   <- A TRMM_IN(m)
RW    B   <- B(m, n)
          -> (m == 0)     ? B(m, n)   : C GEMM(m, n, m-1)
READ  CTL <- (m == Bmt-1) ? CTL(m, n) : CTL1 GOK(m+1, n, m)              [CONTROL]

BODY
      DRYRUN(
	   CORE_ztrmm(
		  side, uplo, trans, diag,
		  m == Bmt-1 ? Bm - m * Bmb : Bmb,
		  n == Bnt-1 ? Bn - n * Bnb : Bnb,
		  alpha, A /*A(k, k)*/, Amb,
		         B /*B(k, n)*/, Bmb)
	   );

      printlog("thread %d trmm( %d, %d )\n"
	       "    ( %s, %s, %s, %s, %d, %d, %f, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d)\n",
	       context->eu_id, m, n, "Left", "Upper", "[Conj]Trans", "[Non]Unit",
	       m == Bmt-1 ? Bm - m * Bmb : Bmb,
	       n == Bnt-1 ? Bn - n * Bnb : Bnb,
	       alpha, m, m, A /*A(k, k)*/, Amb,
	              m, n, B /*B(k, n)*/, Bmb);
END

/**************************************************
 *                      GEMM                      *
 **************************************************/
GEMM_IN_A(k, m)
m = 0..Bmt-1
k = 0..m-1

:A(k, m)

READ A <- A(k, m)
       -> A GEMM(m, 0..Bnt-1, k)

BODY
 /* Nothing */
END

GEMM_IN_B(m, n, k)
m = 0..Bmt-1
n = 0..Bnt-1
k = 0..m-1

: B(k, n)

READ B <- B(k, n)
       -> B GEMM(m, n, k)
BODY
 /* Nothing */
END

// Name
GEMM(m, n, k)

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1
k = 0..m-1

// Parallel partitioning
: B(m, n)

// Parameters
READ  A   <- A GEMM_IN_A(k, m)
READ  B   <- B GEMM_IN_B(m, n, k)
RW    C   <- (k == m-1) ? B TRMM(m, n) : C GEMM(m, n, k+1)
          -> (k == 0)   ? B(m, n)      : C GEMM(m, n, k-1)
RW    CTL <- CTL(m, n)                                          [CONTROL]
          -> CTL2 GOK(m, n, k)                                  [CONTROL]
BODY
      DRYRUN(
	   CORE_zgemm(
		  trans, PlasmaNoTrans,
		  m == Bmt-1 ? Bm-m*Bmb : Bmb,
		  n == Bnt-1 ? Bn-n*Bnb : Bnb,
		  Amb,
		  alpha, A, Amb,
		         B, Bmb,
		  (Dague_Complex64_t)1.0, C, Bmb)
	   );

      printlog("thread %d gemm( %d, %d, %d )\n"
	       "    ( %s, %s, %d, %d, %d, %f, A(%d,%d)[%p], %d, B(%d,%d)[%p], %d, %f, B(%d,%d)[%p], %d)\n",
	       context->eu_id, m, n, k, "NoTrans", "NoTrans", 
	       m == Bmt-1 ? Bm-m*Bmb : Bmb,
	       n == Bnt-1 ? Bn-n*Bnb : Bnb,
	       Amb,
	       alpha, k, m, A, Bmb, k, n, B, Bmb,
	       (Dague_Complex64_t)1.0, m, n, C, Bmb);
END

/**************************************************
 *                      GOK                       *
 **************************************************/
// Name
GOK(m, n, k)

// Execution space
m = 0..Bmt-1
n = 0..Bnt-1
k = 0..m-1

// Parallel partitioning
: B(m, n)

// Parameters
RW    CTL1 <- (m == Bmt-1) ? CTL(m, n)      : CTL1 GOK(m+1, n, k)    [CONTROL]
           -> (m-1 == k)   ? CTL TRMM(k, n) : CTL1 GOK(m-1, n, k)    [CONTROL]
READ  CTL2 <- CTL GEMM(m, n, k)                                      [CONTROL]
BODY
      /* Fake task to guaranty the end of all gemm using B(m, n) before to start TRMM */
     printlog("thread %d gok( %d, %d, %d )\n", context->eu_id, m, n, k);
END
