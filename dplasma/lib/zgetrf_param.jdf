extern "C" %{
/*
 *  Copyright (c) 2010
 *
 *  The University of Tennessee and The University
 *  of Tennessee Research Foundation.  All rights
 *  reserved.
 *
 * @precisions normal z -> s d c
 *
 */
#define PRECISION_z

#include "dague.h"
#include <math.h>
#include <plasma.h>
#include <core_blas.h>

#include "data_distribution.h"
#include "data_dist/matrix/precision.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "dplasma_qr_pivgen.h"

#define MYMIN(a, b) ((a)<(b)?(a):(b))
#define MYMAX(a, b) ((a)>(b)?(a):(b))
#define min( __a, __b ) ( (__a) < (__b) ? (__a) : (__b) )

//#define PRIO_YVES1

#if defined(PRIO_YVES1)
#define GETPRIO_PANEL( __m, __n )      descA.mt * descA.nt - ((descA.nt - (__n) - 1) * descA.mt + (__m) + 1)
#define GETPRIO_UPDTE( __m, __n, __k ) descA.mt * descA.nt - ((descA.nt - (__n) - 1) * descA.mt + (__m) + 1)
#elif defined(PRIO_YVES2)
#define GETPRIO_PANEL( __m, __n )      descA.mt * descA.nt - ((__m) * descA.nt + descA.nt - (__n))
#define GETPRIO_UPDTE( __m, __n, __k ) descA.mt * descA.nt - ((__m) * descA.nt + descA.nt - (__n))
#elif defined(PRIO_MATHIEU1)
#define GETPRIO_PANEL( __m, __n )      (descA.mt + (__n) - (__m) - 1) * descA.nt + (__n)
#define GETPRIO_UPDTE( __m, __n, __k ) (descA.mt + (__n) - (__m) - 1) * descA.nt + (__n)
#elif defined(PRIO_MATHIEU2)
#define GETPRIO_PANEL( __m, __n )      ((MYMAX(descA.mt, descA.nt) - MYMAX( (__n) - (__m), (__m) - (__n) ) -1 ) * 12 + (__n))
#define GETPRIO_UPDTE( __m, __n, __k ) ((MYMAX(descA.mt, descA.nt) - MYMAX( (__n) - (__m), (__m) - (__n) ) -1 ) * 12 + (__n))
#elif defined(PRIO_MATYVES)
#define FORMULE( __x ) ( ( -1. + sqrt( 1. + 4.* (__x) * (__x)) ) * 0.5 )
#define GETPRIO_PANEL( __m, __k )      (int)( 22. * (__k) + 6. * ( FORMULE( descA.mt ) - FORMULE( (__m) - (__k) + 1. ) ) )
#define GETPRIO_UPDTE( __m, __n, __k ) (int)( (__m) < (__n) ? GETPRIO_PANEL( (__n), (__n) ) - 22. * ( (__m) - (__k) ) - 6. * ( (__n) - (__m) ) \
                                              :               GETPRIO_PANEL( (__m), (__n) ) - 22. * ( (__n) - (__k) ) )
#else
  /*#warning running without priority*/
#define GETPRIO_PANEL( __m, __n )      0
#define GETPRIO_UPDTE( __m, __n, __k ) 0
#endif

%}

descA   [type = "tiled_matrix_desc_t"]
A       [type = "dague_ddesc_t *"]
IPIV    [type = "dague_ddesc_t *" aligned=A]
descLT  [type = "tiled_matrix_desc_t"]
LT      [type = "dague_ddesc_t *" aligned=A]
pivfct  [type = "qr_piv_t*"]
ib      [type = int]
p_work  [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)*ib*(descLT.nb))"]
p_tau   [type = "dague_memory_pool_t *" size = "(sizeof(PLASMA_Complex64_t)   *(descLT.nb))"]
INFO    [type = "int*"]

param_p [type = int default="pivfct->p"      hidden=on]
param_a [type = int default="pivfct->a"      hidden=on]
param_d [type = int default="pivfct->domino" hidden=on]

zgetrf_param_out(k, i)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}

  : A(m, k)

  RW A <- A zgetrf_param(k, i)
       -> ( descA.nt-1 > k ) ? A zgessm(k, i, (k+1)..(descA.nt-1)) [type = LOWER_TILE]
       -> A(m, k)                                                  [type = LOWER_TILE]
BODY
 /* Nothing */
END



zgetrf_param(k, i)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}
  nextm = inline_c %{ return dplasma_qr_nextpiv( pivfct, m, k, descA.mt); %}

  SIMCOST 4

  : A(m, k)

  /* A == A(m, k) */
  /* T == T(m, k) */

  RW    A <- ( 0 == k ) ? A(m, k)
          <- ( k > 0  ) ? C zttmqr(k-1, m, k )
          -> A zgetrf_param_out(k, i)
          //-> (descA.nt-1 > k) ? A zunmqr(k, i, (k+1)..(descA.nt-1))
          -> ( k == descA.mt-1 ) ? A(m, k)                                     [type = UPPER_TILE]
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ?  A zttqrt(k, nextm)  [type = UPPER_TILE]
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ?  C zttqrt(k, m)      [type = UPPER_TILE]
  RW    P <- IPIV(m, k)                                                        [type = PIVOT]
          -> IPIV(m, k)                                                        [type = PIVOT]
          -> (descA.nt-1 > k) ? P zgessm(k, i, (k+1)..(descA.nt-1))            [type = PIVOT]

  ; inline_c %{ return GETPRIO_PANEL(m, k); %}

BODY

  int iinfo = 0;
  DRYRUN(
         int tempkm = (k == (descA.mt-1)) ? (descA.m - k * descA.mb) : descA.mb;
         int tempkn = (k == (descA.nt-1)) ? (descA.n - k * descA.nb) : descA.nb;
         int ldak   = BLKLDD( descA, k );

         /* Set local IPIV to 0 before generation
          * Better here than a global initialization for locality
          * and it's also done in parallel */
         memset(P, 0, min(tempkn, tempkm) * sizeof(int) );

         CORE_zgetrf_incpiv(tempkm, tempkn, ib,
                            A /* A(   m, k) */, ldak,
                            P /* IPIV(m, k) */, &iinfo );

         if ( (iinfo != 0) && (k == descA.mt-1) ) {
             *INFO = k * descA.mb + iinfo; /* Should return if enter here */
             fprintf(stderr, "zgetrf(%d, %d) failed => %d\n", k, m, *INFO );
         }
         );

   printlog("thread %d   CORE_zgetrf(%d)\n"
            "\t(tempkm, tempkn, ib, A(%d,%d)[%p], ldak, IPIV(%d,%d)[%p]) => info = %d\n",
            context->eu_id, k, k, k, A, k, k, P, k * descA.mb + iinfo);

END


zgessm(k, i, n)
  /* Execution space */
  k = 0..( ( descA.mt < descA.nt ) ? descA.mt-1 : descA.nt-1)
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( pivfct, k, descA.mt ) - 1; %}
  n = k+1..descA.nt-1
  m = inline_c %{ return dplasma_qr_getm( pivfct, k, i); %}
  nextm = inline_c %{ return dplasma_qr_nextpiv( pivfct, m, k, descA.mt); %}

  SIMCOST 6

  : A(m, n)

  /* A == A(m,k) */
  /* T == T(m,k) */
  /* C == A(m,n) */

  READ  A <- A zgetrf_param_out(k, i)                                     [type = LOWER_TILE]
  READ  P <- P zgetrf_param(k, i)                                         [type = PIVOT]
  RW    C <- ( 0 == k ) ? A(m, n)
          <- ( k >  0 ) ? C zttmqr(k-1, m, n)
          -> ( k == descA.mt-1 ) ? A(m, n)
          -> ( (k < descA.mt-1) & (nextm != descA.mt) ) ? V zttmqr(k, nextm, n)
          -> ( (k < descA.mt-1) & (nextm == descA.mt) ) ? C zttmqr(k, m,     n)

    ; inline_c %{ return GETPRIO_UPDTE(m, n, k); %}

BODY

  DRYRUN(
         int tempnn = ((n)==(descA.nt-1)) ? (descA.n-(n*descA.nb)) : (descA.nb);
         int tempkm = ((k)==(descA.mt-1)) ? (descA.m-(k*descA.mb)) : (descA.mb);
         int ldak   = BLKLDD( descA, k );

         CORE_zgessm(tempkm, tempnn, tempkm, ib,
                     P /* IPIV(k,k) */,
                     A /* A(k,k) */, ldak,
                     C /* A(k,n) */, ldak );
         );
   printlog("thread %d   CORE_zgessm(%d, %d)\n"
            "\t(tempkm, tempnn, tempkm, ib, IPIV(%d,%d)[%p], \n"
            "\tA(%d,%d)[%p], ldak, A(%d,%d)[%p], ldak)\n",
            context->eu_id, k, n, k, k, P, k, k, A, k, n, C);

END


zttqrt_out_A1(k)
  k = 0..( (descA.mt <= descA.nt) ? descA.mt-2 : descA.nt-1 )
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, k, k, k); %}

  : A(k, k)

  RW A <- A zttqrt( k, prevp )  [type = UPPER_TILE]
       -> A(k, k)               [type = UPPER_TILE]
BODY
/* nothing */
END

zttqrt(k, m)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  p =     inline_c %{ return dplasma_qr_currpiv(pivfct, m, k); %}
  nextp = inline_c %{ return dplasma_qr_nextpiv(pivfct, p, k, m); %}
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, p, k, m); %}
  prevm = inline_c %{ return dplasma_qr_prevpiv(pivfct, m, k, m); %}
  type  = inline_c %{ return dplasma_qr_gettype( pivfct, k, m ); %}
  ip    = inline_c %{ return dplasma_qr_geti(    pivfct, k, p ); %}
  im    = inline_c %{ return dplasma_qr_geti(    pivfct, k, m ); %}

  SIMCOST inline_c %{ return type == 0 ? 6 : 2; %}

  : A(m, k)

  /* A1 == A(p,  k) */
  /* A2 == A(m,  k) */
  /* T  == T2(m, k) */

  RW   A  <- (   prevp == descA.mt ) ? A zgetrf_param(k, ip ) : A zttqrt(k, prevp )     [type = UPPER_TILE]
          -> (   nextp != descA.mt ) ? A zttqrt(k, nextp )                              [type = UPPER_TILE]
          -> ( ( nextp == descA.mt ) & (p == k) ) ? A zttqrt_out_A1(k)                  [type = UPPER_TILE]
          -> ( ( nextp == descA.mt ) & (p != k) ) ? C zttqrt(k, p)                      [type = UPPER_TILE]
  RW   C  <- ( (type == 0) && (k     == 0        ) ) ? A(m, k)
          <- ( (type == 0) && (k     != 0        ) ) ? C zttmqr(k-1, m, k )
          <- ( (type != 0) && (prevm == descA.mt ) ) ? A zgetrf_param(k, im )
          <- ( (type != 0) && (prevm != descA.mt ) ) ? A zttqrt(k, prevm )
          -> A(m, k)
          -> (descA.nt-1 > k)? H zttmqr(k, m, (k+1)..(descA.nt-1))
  RW   L  <- LT(m, k)                                                                   [type = SMALL_L]
          -> LT(m, k)                                                                   [type = SMALL_L]
          -> (descA.nt-1 > k)? L zttmqr(k, m, (k+1)..(descA.nt-1))                      [type = SMALL_L]
  RW   P  <-  ( type == 0 ) ? IPIV(m,k)                                                 [type = PIVOT]
          ->  ( type == 0 ) ? IPIV(m,k)                                                 [type = PIVOT]
          -> (( type == 0 ) && (descA.nt-1 > k) ) ? P zttmqr(k, m, (k+1)..(descA.nt-1)) [type = PIVOT]

 ; inline_c %{ return type == 0 ? GETPRIO_PANEL(p, k) : GETPRIO_PANEL(m, k); %}

BODY
  DRYRUN(
      int tempmm = ((m)==(descA.mt-1)) ? (descA.m-(m*descA.mb)) : (descA.mb);
      int tempkn = ((k)==(descA.nt-1)) ? (descA.n-(k*descA.nb)) : (descA.nb);
      int ldam   = BLKLDD( descA, m );
      void *p_elem_B = dague_private_memory_pop( p_work );

      if ( type == 0 ) {
          int ldak   = BLKLDD( descA, k );
          int iinfo;

           memset(P, 0, min(tempkn, tempmm) * sizeof(int) );
           CORE_ztstrf(tempmm, tempkn, ib, descLT.nb,
                       A  /* A(p,k) */, ldak,
                       C  /* A(m,k) */, ldam,
                       L  /* L(m,k) */, descLT.mb,
                       P /* IPIV(m,k) */,
                       p_elem_B, descLT.nb, &iinfo );

           if ( (iinfo != 0) && (m == descA.mt-1) ) {
               *INFO = k * descA.mb + iinfo; /* Should return if enter here */
               fprintf(stderr, "ztstrf(%d, %d) failed => %d\n", m, k, *INFO );
           }
      } else {
          void *p_elem_A = dague_private_memory_pop( p_tau  );

          CORE_zttqrt(
              tempmm, tempkn, ib,
              A /* A(p, k) */, descA.mb,
              C /* A(m, k) */, ldam,
              L /* T(m, k) */, descLT.mb,
              p_elem_A, p_elem_B );

          dague_private_memory_push( p_tau , p_elem_A );
      }

      dague_private_memory_push( p_work, p_elem_B );
         );

#if defined(DAGUE_SIM)
  ((PLASMA_Complex64_t*)C)[0] = (PLASMA_Complex64_t)(this_task->sim_exec_date);
  if ( ( ( nextp == descA.mt ) & (p == k) ) )
    ((PLASMA_Complex64_t*)H)[0] = (PLASMA_Complex64_t)(this_task->sim_exec_date);
#endif
  printlog("thread %d CORE_zttqrt(%d, %d)\n"
           "\t(tempmm, tempkn, ib, A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, p_elem_A, p_elem_B)\n",
           context->eu_id, k, m, p, k, V, m, k, C, m, k, L);

END


zttmqr_out(k, n)
  k = 0..( (descA.mt < descA.nt) ? descA.mt-2 : descA.nt-2 )
  n = k+1..descA.nt-1
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, k, k, k); %}

  : A(k, n)

  RW A <- V zttmqr( k, prevp, n )
       -> A(k, n)
BODY
/* nothing */
END

zttmqr(k, m, n)
  /* Execution space */
  k = 0..( (descA.mt < descA.nt) ? descA.mt-1 : descA.nt-1 )
  m = k+1..descA.mt-1
  n = k+1..descA.nt-1
  p =     inline_c %{ return dplasma_qr_currpiv(pivfct, m, k); %}
  nextp = inline_c %{ return dplasma_qr_nextpiv(pivfct, p, k, m); %}
  prevp = inline_c %{ return dplasma_qr_prevpiv(pivfct, p, k, m); %}
  prevm = inline_c %{ return dplasma_qr_prevpiv(pivfct, m, k, m); %}
  type  = inline_c %{ return dplasma_qr_gettype( pivfct, k,   m ); %}
  type1 = inline_c %{ return dplasma_qr_gettype( pivfct, k+1, m ); %}
  ip    = inline_c %{ return dplasma_qr_geti(    pivfct, k,   p ); %}
  im    = inline_c %{ return dplasma_qr_geti(    pivfct, k,   m ); %}
  im1   = inline_c %{ return dplasma_qr_geti(    pivfct, k+1, m ); %}

  SIMCOST inline_c %{ return type == 0 ? 12 : 6; %}

  : A(m, n)

  /* V  == A(m, k) */
  /* T  == T(m, k) */
  /* A1 == A(p, n) */
  /* A2 == A(m, n) */

  RW   V  <- (   prevp == descA.mt ) ? C  zgessm( k, ip, n ) : V zttmqr(k, prevp, n )
          -> (   nextp != descA.mt ) ? V zttmqr( k, nextp, n)
          -> ( ( nextp == descA.mt ) && ( p == k ) ) ? A zttmqr_out(p, n)
          -> ( ( nextp == descA.mt ) && ( p != k ) ) ? C zttmqr( k, p, n )
  RW   C  <- ( (type == 0) && (k     == 0        ) ) ? A(m, n)
          <- ( (type == 0) && (k     != 0        ) ) ? C zttmqr(k-1, m, n )
          <- ( (type != 0) && (prevm == descA.mt ) ) ? C  zgessm(k, im, n)
          <- ( (type != 0) && (prevm != descA.mt ) ) ? V zttmqr(k, prevm, n )
          -> ( (type1 != 0 ) && (n==(k+1)) ) ? A  zgetrf_param( k+1, im1 )
          -> ( (type1 != 0 ) && (n>  k+1)  ) ? C  zgessm( k+1, im1, n )
          -> ( (type1 == 0 ) && (n==(k+1)) ) ? C zttqrt( k+1, m )
          -> ( (type1 == 0 ) && (n> (k+1)) ) ? C zttmqr( k+1, m, n )

  READ  H <- C zttqrt(k, m)
  READ  L <- L zttqrt(k, m)                [type = SMALL_L]
  READ  P <- (type == 0 ) ? P zttqrt(k, m) [type = PIVOT]

    ; inline_c %{ return type == 0 ? GETPRIO_UPDTE(p, n, k) : GETPRIO_UPDTE(m, n, k); %}

BODY
  DRYRUN(
      int tempnn = ((n)==((descA.nt)-1)) ? ((descA.n)-(n*(descA.nb))) : (descA.nb);
      int tempmm = ((m)==((descA.mt)-1)) ? ((descA.m)-(m*(descA.mb))) : (descA.mb);
      int ldam   = BLKLDD( descA, m );

      if ( type == 0 ) {
          int ldak = BLKLDD( descA, k );

          CORE_zssssm(descA.nb, tempnn, tempmm, tempnn, descA.nb, ib,
                      V /* A(p,n) */, ldak,
                      C /* A(m,n) */, ldam,
                      L /* L(m,k) */,  descLT.mb,
                      H /* A(m,k) */,  ldam,
                      P /* IPIV(m,k) */ );
      } else {
          void *p_elem_A = dague_private_memory_pop( p_work );
          int ldwork = ib;

          CORE_zttmqr(
              PlasmaLeft, PlasmaConjTrans,
              descA.mb, tempnn, tempmm, tempnn, descA.nb, ib,
              V /* A(p, n) */, descA.mb,
              C /* A(m, n) */, ldam,
              H /* A(m, k) */, ldam,
              L /* T(m, k) */, descLT.mb,
              p_elem_A, ldwork );

          dague_private_memory_push( p_work, p_elem_A );
      }

         );

  printlog("thread %d CORE_zttmqr(%d, %d, %d)\n"
           "\t(PlasmaLeft, PlasmaConjTrans, descA.mb, tempnn, tempmm, tempnn, descA.nb, ib, \n"
           "\t A(%d,%d)[%p], A.mb, A(%d,%d)[%p], ldam, A(%d,%d)[%p], ldam, T(%d,%d)[%p], descLT.mb, p_elem_A, ldwork)\n",
           context->eu_id, k, m, n, p, n, A1, m, n, A2, m, k, V, m, k, T);

END
