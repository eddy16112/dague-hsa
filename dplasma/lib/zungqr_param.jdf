extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include "dague.h"
#include <math.h>
#include <plasma.h>
#include <core_blas.h>

#include "data_distribution.h"
#include "dplasma/lib/memory_pool.h"
#include "dplasma/lib/dplasmajdf.h"
#include "data_dist/matrix/matrix.h"
#include "dplasma/lib/pivgen.h"

#define PRECISION_z
#define BLKLDD(_desc, _k) (_desc).mb

%}

descA  [type = "tiled_matrix_desc_t"]
A      [type = "dague_ddesc_t *"]
descT1 [type = "tiled_matrix_desc_t"]
T1     [type = "dague_ddesc_t *" aligned=A]
descT2 [type = "tiled_matrix_desc_t"]
T2     [type = "dague_ddesc_t *" aligned=A]
descQ  [type = "tiled_matrix_desc_t"]
Q      [type = "dague_ddesc_t *"]
pivfct [type = "qr_piv_t*"]
ib     [type = "int" ]
p_work [type = "dague_memory_pool_t *" size = "((sizeof(PLASMA_Complex64_t))*ib)*(descT.nb)"]
minMN  [type = "int" hidden=on default="( (descA.mt < descA.nt) ? descA.mt : descA.nt )" ]
param_p[type = int default="pivfct->p" hidden=on]
param_a[type = int default="pivfct->a" hidden=on]

zttmqr(k, m, n)
  /* Execution space */
  k = 0..minMN-1
  m = k+1..descQ.mt-1
  n = 0..descQ.nt-1
  p     = inline_c %{ return pivfct->currpiv(pivfct, m, k); %}
  nextp = inline_c %{ return pivfct->nextpiv(pivfct, p, k, m); %}
  prevp = inline_c %{ return pivfct->prevpiv(pivfct, p, k, m); %}
  prevm = inline_c %{ return pivfct->prevpiv(pivfct, m, k, m); %}
  type  = inline_c %{ return dplasma_qr_gettype( param_a, param_p, k, m ); %}
  ip    = inline_c %{ return dplasma_qr_geti( param_a, param_p, k,   p ); %}
  ip1   = inline_c %{ return dplasma_qr_geti( param_a, param_p, k+1, p ); %}
  im    = inline_c %{ return dplasma_qr_geti( param_a, param_p, k,   m ); %}
  im1   = inline_c %{ return dplasma_qr_geti( param_a, param_p, k+1, m ); %}
  
  : Q(m, n)
  /* Execution space */

  /* A == Q(minMN-1-k,     n        ) */
  /* B == Q(descQ.mt-1-m, n        ) */
  /* C == A(descQ.mt-1-m, minMN-1-k) */
  /* D == T(descQ.mt-1-m, minMN-1-k) */
  /* G == Q(minMN-1-k,     n1       ) */

  RW   A1 <- (   nextp != descQ.mt ) ? A1 zttmqr( k, nextp, n)
          <- ( ( nextp == descQ.mt ) & ( p == k ) ) ? A  zttmqr_in_A1(p, n)
          <- ( ( nextp == descQ.mt ) & ( p != k ) ) ? A2 zttmqr( k, p, n )
          -> (   prevp == descQ.mt ) ? C zunmqr( k, ip, n ) : A1 zttmqr(k, prevp, n )

  RW   A2 <- ( (type == 0) && (m/param_p == (k+1)) ) ? C  zunmqr( k+1, im1, n )
          <- ( (type == 0) && (m/param_p >  (k+1)) ) ? A2 zttmqr( k+1, m, n ) 
          <- ( (type != 0)  ) ? C zunmqr( k+1, im1, n )
          -> ( (type == 0) && (k     == 0        ) ) ? Q(m, n)
          -> ( (type == 0) && (k     != 0        ) ) ? A2 zttmqr(k-1, m, n )
          -> ( (type != 0) && (prevm == descQ.mt ) ) ? C  zunmqr(k, im, n)
          -> ( (type != 0) && (prevm != descQ.mt ) ) ? A1 zttmqr(k, prevm, n )

  READ  V <- V zttmqr_in_V(k, m) 
  READ  T <- T zttmqr_in_T(k, m) [type = LITTLE_T]

  /*
  The following is a superset of the necessary anti-dependencies:

  */
BODY

   printlog("thread %d CORE_zttmqr(%d, %d, %d)\n\t(PlasmaLeft, PlasmaNoTrans, \n"
            "\tdescQ.mb, tempnn, tempmm, tempnn, tempAkn, ib, \n"
            "\tQ(%d,%d)[%p], ldqk, Q(%d,%d)[%p], ldqm, \n"
            "\tA(%d,%d)[%p], ldam, T(%d,%d)[%p], descT.mb, p_elem_A, ldwork)\n",
            context->eu_id, k, m, n, (minMN-1)-k, n, A, ((descQ.mt)-1)-m, n, B, 
            ((descQ.mt)-1)-m, (minMN-1)-k, C, ((descQ.mt)-1)-m, (minMN-1)-k, D);

  DRYRUN(
         int tempnn  = ( n == descQ.nt-1 ) ? descQ.n - n * descQ.nb : descQ.nb;
         int tempmm  = ( m == descQ.mt-1 ) ? descQ.m - m * descQ.mb : descQ.mb;
         int tempAkn = ( k == descA.nt-1 ) ? descA.n - k * descA.nb : descA.nb;
         int ldqk = BLKLDD( descQ, k );
         int ldqm = BLKLDD( descQ, m );
         int ldam = BLKLDD( descA, m );
         int ldwork = ib;
         
         void *p_elem_A = dague_private_memory_pop( p_work );
         
#line 23 "zungqr.cpp"
         if ( type == 0 ) {
             CORE_zttmqr(
                 PlasmaLeft, PlasmaNoTrans, 
                 descQ.mb, tempnn, tempmm, tempnn, tempAkn, ib, 
                 A1 /* Q(p, n) */, ldqk, 
                 A2 /* Q(m, n) */, ldqm, 
                 V  /* A(m, k) */, ldam, 
                 T  /* T(m, k) */, descT.mb, 
                 p_elem_A, ldwork );
         } else {
             CORE_zttmqr(
                 PlasmaLeft, PlasmaNoTrans, 
                 descQ.mb, tempnn, tempmm, tempnn, tempAkn, ib, 
                 A1 /* Q(p, n) */, ldqk, 
                 A2 /* Q(m, n) */, ldqm, 
                 V  /* A(m, k) */, ldam, 
                 T  /* T(m, k) */, descT.mb, 
                 p_elem_A, ldwork );
         }
         
         dague_private_memory_push( p_work, p_elem_A );
         );

END

/*
 * Pseudo-task
 */
zttmqr_in_A1(k, n)
  k = 0..( (descQ.mt < descQ.nt) ? descQ.mt-2 : descQ.nt-2 )
  n = k+1..descQ.nt-1
  prevp = inline_c %{ return pivfct->prevpiv(pivfct, k, k, k); %}

  : Q(k, n)
  
  RW A -> Q(k, n)
       -> A1 zttmqr( k, prevp, n )
BODY
/* nothing */
END

/*
 * Pseudo-task
 */
zttmqr_in_V(k, m)
  /* k = MAX(0,minMN+1-descQ.mt)..(minMN-1) */
  k = 0..minMN-1
  m = k+1..descQ.mt-1

  : A(m, k)

  RW V <- A(m, k)
       -> V zttmqr(k, m, 0..descQ.nt-1)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zttmqr_in_T(k, m)
  k = 0..minMN-1
  m = k+1..descQ.mt-1

  : T2(m, k)

  RW T <- T2(m, k)
       -> T zttmqr(k, m, 0..descQ.nt-1)
BODY
/* nothing */
END


zunmqr(k, i, n)
  /* Execution space */
  k = 0..minMN-1
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( param_a, param_p, k, descQ.mt ) - 1; %}
  n = 0..descQ.nt-1
  m = inline_c %{ return dplasma_qr_getm( param_a, param_p, k, i); %}
  nextm = inline_c %{ return pivfct->nextpiv( pivfct, m, k, descQ.mt); %}

  : Q(m, n)

  READ  A <- A zunmqr_in_A(k, i)        [type = LOWER_TILE]
  READ  T <- T zunmqr_in_T(k, i)        [type = LITTLE_T]

  RW    C <- ( k == minMN-1 ) ? Q(m, n)   
          <- ( (k < minMN-1) & (nextm != descQ.mt) ) ? A1 zttmqr(k, nextm, n)
          <- ( (k < minMN-1) & (nextm == descQ.mt) ) ? A2 zttmqr(k, m,     n)
          -> ( 0 == k ) ? Q(m, n)
          -> ( k >  0 ) ? A2 zttmqr(k-1, m, n) 

  /*
  The following is a superset of the necessary anti-dependencies:

  */

BODY

  printlog("thread %d CORE_zunmqr(%d, %d)\n\t(PlasmaLeft, PlasmaNoTrans, tempkm, tempnn, tempkmin, ib, \n"
           "\tA(%d,%d)[%p], ldak, T(%d,%d)[%p], descT.mb, Q(%d,%d)[%p], ldqk, p_elem_A, descT.nb)\n",
           context->eu_id, k, n1, (minMN-1)-k, (minMN-1)-k, E, (minMN-1)-k, (minMN-1)-k, F, (minMN-1)-k, n1, G);

     DRYRUN(
         int tempAkm  = ( k == descA.mt-1 ) ? descA.m - k * descA.mb : descA.mb;
         int tempAkn  = ( k == descA.nt-1 ) ? descA.n - k * descA.nb : descA.nb;
         int tempkm   = ( k == descQ.mt-1 ) ? descQ.m - k * descQ.mb : descQ.mb;
         int tempnn   = ( n == descQ.nt-1 ) ? descQ.n - n * descQ.nb : descQ.nb;
         int tempkmin = ( tempAkn < tempAkm ) ? tempAkn : tempAkm ;
         int ldak = BLKLDD( descA, k );
         int ldqk = BLKLDD( descQ, k );
         
         void *p_elem_A = dague_private_memory_pop( p_work );
         
#line 28 "zungqr.cpp"
         CORE_zunmqr(PlasmaLeft, PlasmaNoTrans, 
                     tempkm, tempnn, tempkmin, ib, 
                     A /* A(k, k) */, ldak, 
                     T /* T(k, k) */, descT.mb, 
                     C /* Q(k, n) */, ldqk, 
                     p_elem_A, descT.nb );

         dague_private_memory_push( p_work, p_elem_A );
         );
END

/*
 * Pseudo-task
 */
zunmqr_in_A(k, i)
  k = 0..minMN-1
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( param_a, param_p, k, descQ.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( param_a, param_p, k, i); %}
  
  : A( m, k )

  RW A <- A( m, k )
       -> A zunmqr(k, i, 0..descQ.nt-1)
BODY
/* nothing */
END


/*
 * Pseudo-task
 */
zunmqr_in_T(k, i)
  k = 0..minMN-1
  i = 0..inline_c %{ return dplasma_qr_getnbgeqrf( param_a, param_p, k, descQ.mt ) - 1; %}
  m = inline_c %{ return dplasma_qr_getm( param_a, param_p, k, i); %}
  
  : T1( m, k )

  RW T <- T1( m, k )
       -> T zunmqr(k, i, 0..descQ.nt-1)
BODY
/* nothing */
END
