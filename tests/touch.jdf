extern "C" %{
#include "dague.h"
#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include "touch.h"
%}

A          [type = "two_dim_block_cyclic_t*"]
NT         [type = int]

STARTUP(k)

  k = 0 .. NT
: A(k,0)

  WRITE A1 -> A2 TASK1(k)
BODY
  printf("STARTUP(%d)\n", k);
END

TASK1(k)
  k = 0 .. NT
: A(k,0)

  WRITE A3 -> A1 TASK2(k)
  RW    A1 <- A(k,0)
           -> A2 TASK2(k)
  READ  A2 <- A1 STARTUP(k)

BODY
  printf("TASKS1(%d)\n", k);
END

TASK2(k)
  k = 0 .. NT
: A(k,0)

  READ A1 <- A3 TASK1(k)
  RW   A2 <- A1 TASK1(k)
          -> A(k, 0)

BODY
  printf("TASKS2(%d)\n", k);
END

extern "C" %{

#define TYPE  matrix_RealFloat
static two_dim_block_cyclic_t descA;

dague_handle_t* touch_initialize(int block, int n)
{
    dague_touch_handle_t* handle;

    two_dim_block_cyclic_init( &descA, TYPE, matrix_Tile,
                               1 /*nodes*/, 0 /*rank*/,
                               block, block, n, n,
                               0, 0, n, n, 1, 1, 1);
    descA.mat = dague_data_allocate( descA.super.nb_local_tiles *
                                     descA.super.bsiz *
                                     dague_datadist_getsizeoftype(TYPE) );

    handle = dague_touch_new( &descA, (n / block) -1 );
    assert( NULL != handle );
#ifdef HAVE_MPI
    {
        int provided;
        MPI_Init_thread(NULL, NULL, MPI_THREAD_SERIALIZED, &provided);
    }
#endif

    dague_arena_construct( handle->arenas[DAGUE_touch_DEFAULT_ARENA],
                           descA.super.mb * descA.super.nb * dague_datadist_getsizeoftype(TYPE),
                           DAGUE_ARENA_ALIGNMENT_SSE,
                           DAGUE_DATATYPE_NULL);  /* change for distributed cases */

    return &handle->super;
}

int touch_finalize(void)
{
    free(descA.mat);

#ifdef HAVE_MPI
    MPI_Finalize();
#endif
    return 0;
}

%}

