extern "C" %{
#include "dague.h"
#include "data_dist/matrix/two_dim_rectangle_cyclic.h"
#include <sys/time.h>
#include <inttypes.h>
#include <string.h>
%}

A          [type = "two_dim_block_cyclic_t*"]
NI         [type = int]
NJ         [type = int]
NK         [type = int]
pri        [type = int default = 0 hidden = on]

STARTUP(i, j, k)

  i = 0 .. NI-1
  j = 0 .. NJ-1
  k = 0 .. NK-1

: A(i,0)

  READ A <- A(i, 0)
         -> A(i, 0)

; inline_c %{ return ((NI-1)*i + (NJ-1)*j + (NK-1)*k)*pri; %}

BODY
END

extern "C" %{

#define BLOCK 10
#define N     100
#define NN    10
#define TYPE  matrix_RealFloat

#define TIMER_START(TIMER)                      \
    do {                                        \
        struct timeval tv;                      \
        gettimeofday(&tv,NULL);                 \
        (TIMER) = tv.tv_sec * 1e6 + tv.tv_usec; \
    } while (0)
    
#define TIMER_STOP(TIMER)                                   \
    do {                                                    \
        struct timeval tv;                                  \
        gettimeofday(&tv,NULL);                             \
        (TIMER) = (tv.tv_sec * 1e6 + tv.tv_usec) - (TIMER); \
    } while (0)

int main( int argc, char** argv )
{
    dague_startup_object_t* object;
    two_dim_block_cyclic_t descA;
    dague_arena_t arena;
    dague_context_t *dague;
    int ni = NN, nj = NN, nk = NN, i = 1;
    long time_elapsed;

    while( NULL != argv[i] ) {
        if( 0 == strcmp(argv[i], "-i") ) {
            ni = strtol(argv[i+1], NULL, 10);
            goto move_and_continue;
        }
        if( 0 == strcmp(argv[i], "-j") ) {
            nj = strtol(argv[i+1], NULL, 10);
            goto move_and_continue;
        }
        if( 0 == strcmp(argv[i], "-k") ) {
            nk = strtol(argv[i+1], NULL, 10);
            goto move_and_continue;
        }
        i++;  /* skip this one */
        continue;
    move_and_continue:
        memmove(&argv[i], &argv[i+2], (argc - 2) * sizeof(char*));
        argc -= 2;
    }
    dague = dague_init(1, &argc, &argv);
    assert( NULL != dague );

    /**
     * Build the data and the arena to hold it up.
     */
    two_dim_block_cyclic_init( &descA, TYPE, matrix_Tile,
                               1 /*nodes*/, 1 /*cores*/, 0 /*rank*/,
                               BLOCK, BLOCK, NN, 1,
                               0, 0, NN, 1, 1, 1, 1);
    descA.mat = dague_data_allocate( descA.super.nb_local_tiles *
                                     descA.super.bsiz *
                                     dague_datadist_getsizeoftype(TYPE) );
    dague_arena_construct( &arena,
                           descA.super.mb * descA.super.nb * dague_datadist_getsizeoftype(TYPE),
                           DAGUE_ARENA_ALIGNMENT_SSE,
                           NULL);  /* change for distributed cases */

    /* Heat up the engine: small tasks no priority */
    object = dague_startup_new( &descA, 10, 10, 10 );
    assert( NULL != object );
    object->arenas[DAGUE_startup_DEFAULT_ARENA] = &arena;
    object->pri = 0;
    dague_enqueue( dague, (dague_object_t*)object );
    dague_progress(dague);

    /* No priority */
    object = dague_startup_new( &descA, ni, nj, nk );
    assert( NULL != object );
    TIMER_START(time_elapsed);
    object->arenas[DAGUE_startup_DEFAULT_ARENA] = &arena;
    object->pri = 0;
    dague_enqueue( dague, (dague_object_t*)object );
    TIMER_STOP(time_elapsed);
    printf("DAG construction [%d] %d tasks in %ld micro-sec\n", object->pri,
           object->super.nb_local_tasks, time_elapsed);
    TIMER_START(time_elapsed);
    dague_progress(dague);
    TIMER_STOP(time_elapsed);
    printf("DAG execution [%d] in %ld micro-sec\n", object->pri, time_elapsed);

    /* Increasing */
    object = dague_startup_new( &descA, ni, nj, nk );
    assert( NULL != object );
    TIMER_START(time_elapsed);
    object->arenas[DAGUE_startup_DEFAULT_ARENA] = &arena;
    object->pri = 1;
    dague_enqueue( dague, (dague_object_t*)object );
    TIMER_STOP(time_elapsed);
    printf("DAG construction [%d] %d tasks in %ld micro-sec\n", object->pri,
           object->super.nb_local_tasks, time_elapsed);
    TIMER_START(time_elapsed);
    dague_progress(dague);
    TIMER_STOP(time_elapsed);
    printf("DAG execution [%d] in %ld micro-sec\n", object->pri, time_elapsed);

    /* No priority */
    object = dague_startup_new( &descA, ni, nj, nk );
    assert( NULL != object );
    TIMER_START(time_elapsed);
    object->arenas[DAGUE_startup_DEFAULT_ARENA] = &arena;
    object->pri = -1;
    dague_enqueue( dague, (dague_object_t*)object );
    TIMER_STOP(time_elapsed);
    printf("DAG construction [%d] %d tasks in %ld micro-sec\n", object->pri,
           object->super.nb_local_tasks, time_elapsed);
    TIMER_START(time_elapsed);
    dague_progress(dague);
    TIMER_STOP(time_elapsed);
    printf("DAG execution [%d] in %ld micro-sec\n", object->pri, time_elapsed);

    free(descA.mat);

    dague_fini( &dague);

    return 0;
}

%}
