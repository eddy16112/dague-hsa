#!/usr/bin/env python

# this is a PURE PYTHON interface to
# pure Python objects generated by py_dbpreader.

# It is especially suitable for use when a separate
# Python program has done the reading of the profile
# and stored the profile in this format in some sort
# of cross-process format, such as a pickle.

import copy, sys
import cPickle

class Profile(list): # contains Events
    class_version = 1.0 # created as replacement for multifile_reader on 2013-05-22
    @staticmethod
    def unpickle(filepath, load_events=True):
        f = open(filepath, 'r')
        profile = cPickle.load(f)
        if load_events:
            # load event list, sort them into appropriate bins
            profile = cPickle.load(f) # the second pickle contains all the events
        f.close()
        return profile
    def pickle(self, filepath, protocol=cPickle.HIGHEST_PROTOCOL):
        f = open(filepath, 'w')
        # 1: dump object with events removed
        cPickle.dump(self.get_eventless(), f, protocol)
        # 2: dump entire object with all references intact
        cPickle.dump(self, f, protocol)
        f.close()
    def __init__(self):
        self.__version__ = self.__class__.class_version
        self.event_types = dict()
        self.type_key_to_name = dict()
        self.files = dict()
        self.handles = dict()
        self.errors = dict()
        # debug dicts
        # self.begin_ids = dict()
        # self.end_ids = dict()
    def get_handle_counts(self):
        if self.is_eventless():
            return self.handle_counts
        self.handle_counts = dict()
        for key, value in self.handles.iteritems():
            self.handle_counts[key] = len(value)
        return self.handle_counts
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
    def is_eventless(self):
        for key, handle  in self.handles.iteritems():
            if len(handle) > 0:
                return False
        return True
    def get_eventless(self):
        # generate event-dependent statistics
        self.get_handle_counts()
        # backup and remove all events from their containers
        all_events = self[:]
        del self[:]
        event_type_events = dict()
        for key, value in self.event_types.iteritems():
            event_type_events[key] = value[:]
            del value[:]
        handle_events = dict()
        for key, handle in self.handles.iteritems():
            handle_events[key] = handle[:]
            del handle[:]
        file_threads = dict()
        file_threads_types = dict()
        for rank, pf in self.files.iteritems():
            file_threads[rank] = dict()
            file_threads_types[rank] = dict()
            for thread in pf.threads:
                file_threads[rank][thread.id] = thread[:]
                del thread[:]
                file_threads_types[rank][thread.id] = dict()
                for name, event_type in thread.event_types.iteritems():
                    file_threads_types[rank][thread.id][name] = event_type[:]
                    del event_type[:]
                
        # create deep copy
        small_pickle = copy.deepcopy(self)
        # restore all events
        self.extend(all_events)
        for key, value in self.event_types.iteritems():
            value.extend(event_type_events[key])
        for key, handle in self.handles.iteritems():
            handle.extend(handle_events[key])
        for rank, pf in self.files.iteritems():
            for thread in pf.threads:
                thread.extend(file_threads[rank][thread.id])
                for name, event_type in thread.event_types.iteritems():
                    event_type.extend(file_threads_types[rank][thread.id][name])
        return small_pickle # return deep copy

class dbpEventType(list): # contains Events
    class_version = 1.0
    def __init__(self, profile, key, attributes):
        self.__version__ = self.__class__.class_version
        self.profile = profile
        self.key = key
        self.attributes = attributes
        self.stats = EventStats(self.profile.type_key_to_name[key])
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0

class dbpFile(object):
    class_version = 1.0
    class_version = 1.1 # hr_id->ex_name
    def __init__(self, parent, ex_name, filename, rank):
        self.__version__ = self.__class__.class_version
        self.profile = parent
        self.rank = rank
        self.ex_name = ex_name
        self.filename = filename
        self.infos = list()
        self.threads = list()
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.ex_name = self.hr_id
            del self['hr_id']
            self.__version__ = 1.1

class dbpInfo(object):
    class_version = 1.0
    def __init__(self, ikey, value):
        self.__version__ = self.__class__.class_version
        self.key = ikey
        self.value = value

class dbpHandle(list): # contains Events
    class_version = 1.0
    def __init__(self, profile, id):
        self.__version__ = self.__class__.class_version
        self.profile = profile
        self.id = id
        self.event_types = dict()
        
class dbpThread(list): # contains Events
    class_version = 1.0
    class_version = 1.1 # turned it into a list
    def __init__(self, parent_file, thread_number):
        self.__version__ = self.__class__.class_version
        self.file = parent_file
        self.id = int(thread_number) # if it's not a number, it's wrong
        self.event_types = dict()
        self.begin = sys.maxint
        self.end = 0
        self.duration = 0
        self.starvation = 0
    def __str__(self):
        return str(self.id)
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.extend(self.events)
            del self['events']
            self.__version__ = 1.1

class dbpEvent(object):
    class_version = 1.0
    class_version = 1.1 # renamed 'start' to 'begin'
    __max_length__ = 0
    # keep the print order updated as attributes are added
    print_order = ['handle_id', 'thread_id', 'event_id', 'key',  
                   'flags', 'begin', 'end', 'duration', 'info']
    def __init__(self, thread, key, flags, handle_id, event_id, begin, end):
        self.__version__ = self.__class__.class_version
        self.file_rank = thread.file.rank
        self.thread_id = thread.id
        self.handle_id = handle_id
        self.event_id = event_id
        self.key = key
        self.flags = flags
        self.begin = begin
        self.end = end
        self.duration = self.end - self.begin
        self.info = None
        for attr, value in vars(self).items():
            if attr[:2] == '__':
                continue # skip special attributes
            if len(attr) > dbpEvent.__max_length__:
                dbpEvent.__max_length__ = len(attr)
            # values that we don't want printed generically
            elif attr == 'info':
                value = 'Yes' if self.info else 'No'
            if len(str(value)) > dbpEvent.__max_length__:
                dbpEvent.__max_length__ = len(str(value))
        if (self.duration < 0):
            print(self)
    def row(self):
        row = ''
        for attr in dbpEvent.print_order:
            value = vars(self)[attr]
            # values that we don't want printed generically
            if attr == 'info':
                value = 'Yes' if self.info else 'No'
            row += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(value)
        return row
    def row_header(self):
        # first, establish max length
        header = ''
        for attr in dbpEvent.print_order:
            header += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(attr)
        return header
    def __repr__(self):
        return self.row()
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.begin = self.start
            
class EventStats(object):
    class_version = 1.0 # added versioning
    class_version = 1.1 # separated 'papi_stats' into socket_stats, exec_stats, select_stats
    class_version = 1.2 # duration->total_duration
    @classmethod
    def class_row_header(cls):
        return ('{:16} {:>15} {:>12}').format(
            'EVT_NAME', 'COUNT','DURATION/CT')
    ############
    def __init__(self, name):
        self.__version__ = self.__class__.class_version
        self.name = name
        self.count = 0
        self.total_duration = 0
        self.starvation = 0.0
        self.socket_stats = {} # hashed by nothing, really... TODO: should this be a single item?
        self.exec_stats = {}   # hashed by task name
        self.select_stats = {} # hashed by task name
    def row(self):
        row = '{:16} {:15d} {:12.0f}'.format(
           self.name, self.count, self.total_duration/float(self.count)
        )
        return row
    def row_header(self):
        return self.__class__.class_row_header()
    def __repr__(self):
        return self.row()
    def __add__(self, x):
        if not x:
            return self
        sum_stats = copy.deepcopy(self)
        for attrname in self.__dict__:
            if attrname != 'papi_stats':
                setattr(sum_stats, attrname,
                        getattr(self, attrname) + getattr(x, attrname))
            else:
                for key in self.papi_stats:
                    sum_stats.papi_stats[key] = (
                        self.papi_stats[key] +
                        x.papi_stats[key])
        sum_stats.name = '<<SUM>>'
        return sum_stats
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.socket_stats = dict()
            self.exec_stats = dict()
            self.select_stats = dict()
            for key, stats in self.papi_stats.iteritems():
                if key != 'L3':
                    if hasattr(self.exec_stats, key):
                        self.exec_stats[key] += stats
                    else:
                        self.exec_stats[key] = stats
                else:
                    if hasattr(self.socket_stats, key):
                        self.socket_stats[key] += stats
                    else:
                        self.socket_stats[key] = stats
            self.__version__ = 1.1
        if self.__version__ < 1.2:
            self.total_duration = self.duration
            del self['duration']
            self.name = self.event_name
            del self['event_name']
            self.__version__ = 1.2


# this is the old class. it has been superseded by Profile
class multifile_reader(list): # contains Events
    class_version = 1.0
    class_version = 1.1 # added handle dict and handle counts is now a dict
    def __init__(self):
        self.__version__ = self.__class__.class_version
        self.dictionary = {}
        self.dict_key_to_name = {}
        self.files = []
        self.handles = dict()
        self.stats = ProfileStats()
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(dictionary, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.handles = dict()
            bak_handle_counts = self.handle_counts
            self.handle_counts = dict()
            for index, count in enumerate(bak_handle_counts):
                self.handle_counts[index] = count

# not sure if this gets used?
class d_time(object):
    def __init__(self, seconds, nsec):
        self.sec = seconds
        self.nsec = nsec
    def diff(self, time):
        return d_time(time.sec - self.sec, time.nsec - self.nsec)
    def abs(self):
        return self.sec * 1000000000 + self.nsec

                