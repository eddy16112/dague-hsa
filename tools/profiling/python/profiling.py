#!/usr/bin/env python

# this is a PURE PYTHON interface to
# pure Python objects generated by py_dbpreader.

# It is especially suitable for use when a separate
# Python program has done the reading of the profile
# and stored the profile in this format in some sort
# of cross-process format, such as a pickle.

import copy

class d_time:
    def __init__(self, seconds, nsec):
        self.sec = seconds
        self.nsec = nsec
    def diff(self, time):
        return d_time(time.sec - self.sec, time.nsec - self.nsec)
    def abs(self):
        return self.sec * 1000000000 + self.nsec

class multifile_reader:
    def __init__(self, nb_files, nb_dict_entries):
        self.nb_files = nb_files
        self.nb_dict_entries = nb_dict_entries
        self.dictionary = {}
        self.dict_key_to_name = {}
        self.files = []
        self.thread_count = 0
        self.handle_counts = [0, 0]
        self.event_type_stats = dict()

class dbpDictEntry:
    def __init__(self, key, attributes):
        self.key = key
        self.attributes = attributes

class dbpFile:
    def __init__(self, parent, hr_id, filename, rank):
        self.parent = parent
        self.hr_id = hr_id
        self.filename = filename
        self.rank = rank
        self.infos = []
        self.threads = []

class dbpInfo:
    def __init__(self, ikey, value):
        self.key = ikey
        self.value = value

class dbpThread:
    def __init__(self, parentFile, threadNumber):
        self.file = parentFile
        self.events = []
        self.id = int(threadNumber) # if it's not a number, it's wrong
    def __str__(self):
        return str(self.id)

class dbpEvent:
    class_version = 1.0
    __max_length__ = 0
    # keep the print order updated as attributes are added
    print_order = ['handle_id', 'thread', 'key', 'event_id', 
                   'flags', 'start', 'end', 'duration', 'info']
    def __init__(self, parentThread, key, flags, handle_id, event_id, start, end):
        self.__version__ = self.__class__.class_version
        self.thread = parentThread
        self.key = key
        self.flags = flags
        self.handle_id = handle_id
        self.event_id = event_id
        self.start = start
        self.end = end
        self.duration = self.end - self.start
        self.info = None
        for attr, value in vars(self).items():
            if attr[:2] == '__':
                continue # skip special attributes
            if len(attr) > dbpEvent.__max_length__:
                dbpEvent.__max_length__ = len(attr)
            # values that we don't want printed generically
            elif attr == 'info':
                value = 'Yes' if self.info else 'No'
            if len(str(value)) > dbpEvent.__max_length__:
                dbpEvent.__max_length__ = len(str(value))
    def row(self):
        row = ''
        for attr in dbpEvent.print_order:
            value = vars(self)[attr]
            # values that we don't want printed generically
            if attr == 'info':
                value = 'Yes' if self.info else 'No'
            row += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(value)
        return row
    def row_header(self):
        # first, establish max length
        header = ''
        for attr in dbpEvent.print_order:
            header += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(attr)
        return header
    def __repr__(self):
        return self.row()



class EventStats(object):
    class_version = 1.0 # added versioning
    class_version = 1.1 # separated 'papi_stats' into socket_stats, exec_stats, select_stats
    @classmethod
    def class_row_header(cls):
        return ('{:16} {:>15} {:>12}').format(
            'EVT_NAME', 'COUNT','DURATION/CT')
    ############
    def __init__(self, name, dict_key):
        self.__version__ = self.__class__.class_version
        self.event_name = name
        self.dict_key = dict_key
        self.count = 0
        self.duration = 0
        self.socket_stats = {} # hashed by nothing, really... TODO: should this be a single item?
        self.exec_stats = {}   # hashed by task name
        self.select_stats = {} # hashed by task name
    def row(self):
        row = '{:16} {:15d} {:12.0f}'.format(
           self.event_name, self.count, self.duration/float(self.count)
        )
        return row
    def row_header(self):
        return self.__class__.class_row_header()
    def __repr__(self):
        return self.row()
    def __add__(self, x):
        if not x:
            return self
        sum_stats = copy.deepcopy(self)
        for attrname in self.__dict__:
            if attrname != 'papi_stats':
                setattr(sum_stats, attrname,
                        getattr(self, attrname) + getattr(x, attrname))
            else:
                for key in self.papi_stats:
                    sum_stats.papi_stats[key] = (
                        self.papi_stats[key] +
                        x.papi_stats[key])
        sum_stats.name = '<<SUM>>'
        return sum_stats
    def __setstate__(self, dictionary):
        self.__dict__.update(dictionary)
        if not hasattr(self, '__version__'):
            self.__version__ = 1.0
        if self.__version__ < 1.1:
            self.socket_stats = dict()
            self.exec_stats = dict()
            self.select_stats = dict()
            for key, stats in self.papi_stats.iteritems():
                if key != 'L3':
                    if hasattr(self.exec_stats, key):
                        self.exec_stats[key] += stats
                    else:
                        self.exec_stats[key] = stats
                else:
                    if hasattr(self.socket_stats, key):
                        self.socket_stats[key] += stats
                    else:
                        self.socket_stats[key] = stats
            self.__version__ = 1.1
