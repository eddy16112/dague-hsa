#!/usr/bin/env python

# this is PYTHON-ONLY interface to
# pure Python objects generated by py_dbpreader.

# It is especially suitable for use when a separate
# Python program has done the reading of the profile
# and stored the profile in this format in some sort
# of cross-process format, such as a pickle.

# Note that even though all of this is pure Python,
# py_dbpreader should be recompiled any time the
# class attributes it uses from these classes are changed.

# pure Python

class d_time:
   def __init__(self, seconds, nsec):
      self.sec = seconds
      self.nsec = nsec
   def diff(self, time):
      return d_time(time.sec - self.sec, time.nsec - self.nsec)
   def abs(self):
      return self.sec * 1000000000 + self.nsec

class multifile_reader:
   def __init__(self, nb_files, nb_dict_entries):
      self.nb_files = nb_files
      self.nb_dict_entries = nb_dict_entries
      self.dictionary = {}
      self.files = []
      self.thread_count = 0
      self.handle_counts = [0, 0]

class dbpDictEntry:
   def __init__(self, id, attributes):
      self.id = id
      self.attributes = attributes

class dbpFile:
   def __init__(self, parent, hr_id, filename, rank):
      self.parent = parent
      self.hr_id = hr_id
      self.filename = filename
      self.rank = rank
      self.infos = []
      self.threads = []
      # NOTE: maybe collect statistics on timing stuff later

class dbpInfo:
   def __init__(self, key, value):
      self.key = key
      self.value = value

class dbpThread:
   def __init__(self, parentFile, threadNumber):
      self.file = parentFile
      self.events = []
      self.id = int(threadNumber) # if it's not a number, it's wrong
   def __str__(self):
      return str(self.id)

class dbpEvent:
   __max_length__ = 0
   # keep the print order updated as attributes are added
   print_order = ['handle_id', 'thread', 'key', 'event_id', 
                  'flags', 'start', 'end', 'duration', 'info']
   def __init__(self, parentThread, key, flags, handle_id, event_id, start, end):
      self.thread = parentThread
      self.key = key
      self.flags = flags
      self.handle_id = handle_id
      self.event_id = event_id
      self.start = start
      self.end = end
      self.duration = self.end - self.start
      self.info = None
      for attr, value in vars(self).items():
         if len(attr) > dbpEvent.__max_length__:
            dbpEvent.__max_length__ = len(attr)
         # values that we don't want printed generically
         elif attr == 'info':
            value = 'Yes' if self.info else 'No'
         if len(str(value)) > dbpEvent.__max_length__:
            dbpEvent.__max_length__ = len(str(value))

   def row_header(self):
      # first, establish max length
      header = ''
      for attr in dbpEvent.print_order:
         header += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(attr)
      return header
   def __repr__(self):
      row = ''
      for attr in dbpEvent.print_order:
         value = vars(self)[attr]
         # values that we don't want printed generically
         if attr == 'info':
            value = 'Yes' if self.info else 'No'
         row += ('{:>' + str(dbpEvent.__max_length__) + '}  ').format(value)
      return row


########################################################
############## CUSTOM EVENT INFO SECTION ###############
######### -- add a Python type to this section #########
######### to allow for new 'info' types        #########

class dbp_Exec_EventInfo:
   __max_length__ = 0
   def __init__(self, kernel_type, kernel_name, vp_id, th_id, values):
      self.kernel_type = kernel_type
      self.kernel_name = kernel_name
      self.vp_id = vp_id
      self.th_id = th_id
      self.values = values

      # set global max length
      for attr, val in vars(self).items():
         if len(attr) > dbp_Exec_EventInfo.__max_length__:
            dbp_Exec_EventInfo.__max_length__ = len(attr)
         # values that we don't want printed generically
         elif attr == 'values':
            for value in val:
               if len(str(value)) > dbp_Exec_EventInfo.__max_length__:
                  dbp_Exec_EventInfo.__max_length__ = len(str(value))
         elif len(str(val)) > dbp_Exec_EventInfo.__max_length__:
            dbp_Exec_EventInfo.__max_length__ = len(str(val))

   def row_header(self):
      # first, establish max length
      header = ''
      length = str(dbp_Exec_EventInfo.__max_length__)
      header += ('{:>' + length + '}  ').format('kernel_type')
      header += ('{:>' + length + '}  ').format('kernel_name')
      header += ('{:>' + length + '}  ').format('vp_id')
      header += ('{:>' + length + '}  ').format('th_id')
      header += ('{:>' + length + '}  ').format('values')
      return header

   def __repr__(self):
      rv = ''
      length = str(dbp_Exec_EventInfo.__max_length__)
      rv += ('{:>' + length + '}  ').format(self.kernel_type)
      rv += ('{:>' + length + '}  ').format(self.kernel_name)
      rv += ('{:>' + length + '}  ').format(self.vp_id)
      rv += ('{:>' + length + '}  ').format(self.th_id)
      for value in self.values:
         rv += ('{:>' + length + '}  ').format(value)
      return rv

class dbp_Select_EventInfo:
   __max_length__ = 0
   def __init__(self, kernel_type, vp_id, th_id, victim_vp_id, victim_th_id, exec_context, values):
      self.kernel_type = kernel_type
      self.vp_id = vp_id
      self.th_id = th_id
      self.victim_vp_id = victim_vp_id
      self.victim_th_id = victim_th_id
      self.exec_context = exec_context
      self.values = values

      # set global max length
      for attr, val in vars(self).items():
         if len(attr) > dbp_Select_EventInfo.__max_length__:
            dbp_Select_EventInfo.__max_length__ = len(attr)
         # values that we don't want printed generically
         elif attr == 'values':
            for value in val:
               if len(str(value)) > dbp_Select_EventInfo.__max_length__:
                  dbp_Select_EventInfo.__max_length__ = len(str(value))
         elif len(str(val)) > dbp_Select_EventInfo.__max_length__:
            dbp_Select_EventInfo.__max_length__ = len(str(val))

   def isStarvation(self):
      return self.exec_context == 0

   def isSystemQueueSteal(self):
      return self.victim_vp_id == SYSTEM_QUEUE_VP

   def row_header(self):
      # first, establish max length
      header = ''
      length = str(dbp_Select_EventInfo.__max_length__)
      header += ('{:>' + length + '}  ').format('kernel_type')
      header += ('{:>' + length + '}  ').format('vp_id')
      header += ('{:>' + length + '}  ').format('th_id')
      header += ('{:>' + length + '}  ').format('vict_vp_id')
      header += ('{:>' + length + '}  ').format('vict_th_id')
      header += ('{:>' + length + '}  ').format('exec_context')
      header += ('{:>' + length + '}  ').format('values')
      return header

   def __repr__(self):
      rv = ''
      length = str(dbp_Select_EventInfo.__max_length__)
      rv += ('{:>' + length + '}  ').format(self.kernel_type)
      rv += ('{:>' + length + '}  ').format(self.vp_id)
      rv += ('{:>' + length + '}  ').format(self.th_id)
      rv += ('{:>' + length + '}  ').format(self.victim_vp_id)
      rv += ('{:>' + length + '}  ').format(self.victim_th_id)
      rv += ('{:>' + length + '}  ').format(self.exec_context)

      for value in self.values:
         rv += ('{:>' + length + '}  ').format(value)
      return rv

